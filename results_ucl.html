<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8" />
  <title>BL TippLiga – Eredmények</title>
  <link rel="stylesheet" href="style-themed.css" />
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" href="fav2.png" sizes="16x16">
  <link rel="icon" type="image/png" href="fav2.png" sizes="32x32">
  <link rel="icon" type="image/png" href="fav2.png">
  <script src="loader.js" defer></script>

  <style>
    .layout{max-width:1200px;margin:0 auto;padding:20px;display:flex;flex-direction:column;gap:14px}
    .header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .header-left{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .fav-crest{width:44px;height:44px;object-fit:contain;border-radius:10px;border:1px solid var(--line,#e6eaf1);background:#fff}
    .welcome{color:var(--muted,#64748b);margin:4px 0 0}
    .btn-accent{min-height:40px;padding:10px 14px;border-radius:10px;background:var(--accent,#3b82f6);color:#fff;border:1px solid var(--line,#e6eaf1);font-weight:700;cursor:pointer;display:inline-flex;align-items:center;gap:8px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
    .btn-accent:hover{filter:brightness(.95)}
    .btn-accent:focus{outline:2px solid color-mix(in oklab,var(--accent,#3b82f6) 30%,white);outline-offset:2px}
    .btn-icon{width:18px;height:18px;display:inline-block}

    .card{background:#fff;border:1px solid var(--line,#e6eaf1);border-radius:14px;box-shadow:0 8px 24px rgba(15,23,42,.06);overflow:hidden}
    .card h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--line,#e6eaf1);background:#f7f9fd}
    .card .body{padding:14px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

    .select{border:1px solid var(--line,#e6eaf1);border-radius:10px;padding:10px 12px;background:#fff;min-width:220px}
    .muted{color:var(--muted,#64748b)}
    .kicker{font-size:12px;color:var(--muted,#64748b)}
    .divider{height:1px;background:var(--line,#e6eaf1);margin:12px 0}

    .round{display:grid;gap:12px}
    .match{border:1px solid var(--line,#e6eaf1);border-radius:14px;padding:12px;background:#fff;box-shadow:0 6px 18px rgba(15,23,42,.04)}
    .match-head{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .teams{font-weight:900}
    .meta{font-size:12px;color:var(--muted,#64748b)}
    .score{font-weight:900}
    .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    @media (max-width:900px){.subgrid{grid-template-columns:1fr}}
    .tips{border:1px dashed rgba(148,163,184,.65);border-radius:12px;padding:10px;background:rgba(248,250,252,.85)}
    .tip{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(226,232,240,.9)}
    .tip:last-child{border-bottom:0}
    .tip.correct b{color:#16a34a}
    .tip.wrong b{color:#ef4444}
    .badge{font-size:11px;font-weight:900;border-radius:999px;padding:3px 8px;border:1px solid var(--line,#e6eaf1);background:#fff}
    .hiddenbox{padding:10px;border-radius:12px;background:#0f172a;color:#fff;font-size:13px}
    .sum{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .sum strong{font-size:16px}
    .sum small{color:var(--muted,#64748b)}
    .pill{display:inline-flex;align-items:center;gap:8px}
  </style>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import {
      getFirestore,
      doc, getDoc, setDoc, collection, getDocs, addDoc, deleteDoc,
      query, where, orderBy, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { initLeagueSwitcher } from "./league-switcher.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC2xpMW1xgaWIdI2JoEhK23vkC0FTF2PKc",
      authDomain: "tippliga-4b3af.firebaseapp.com",
      projectId: "tippliga-4b3af",
      storageBucket: "tippliga-4b3af.appspot.com",
      messagingSenderId: "720359845241",
      appId: "1:720359845241:web:d3d6edcac6b43ebff053a8"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const crestMap = {
      "Ajax":"ucl_crest/ajax.png",
      "Arsenal":"ucl_crest/arsenal.png",
      "Atalanta":"ucl_crest/atalanta.png",
      "Athletic Bilbao":"ucl_crest/athletic.png",
      "Atlético Madrid":"ucl_crest/atletico.png",
      "Barcelona":"ucl_crest/barcelona.png",
      "Bayern München":"ucl_crest/bayern.png",
      "Benfica":"ucl_crest/benfica.png",
      "Borussia Dortmund":"ucl_crest/borussia.png",
      "Bodø/Glimt":"ucl_crest/bodo.png",
      "Club Bruges":"ucl_crest/brugge.png",
      "Chelsea":"ucl_crest/chelsea.png",
      "FC Köbenhavn":"ucl_crest/copenhagen.png",
      "Eintracht Frankfurt":"ucl_crest/frankfurt.png",
      "Galatasaray":"ucl_crest/galata.png",
      "Internazionale":"ucl_crest/inter.png",
      "Juventus":"ucl_crest/juventus.png",
      "Bayer Leverkusen":"ucl_crest/leverkusen.png",
      "Liverpool":"ucl_crest/liverpool.png",
      "Manchester City":"ucl_crest/mancity.png",
      "Olympique Marseille":"ucl_crest/marseille.png",
      "Monaco":"ucl_crest/monaco.png",
      "Napoli":"ucl_crest/napoli.png",
      "Newcastle United":"ucl_crest/newcastle.png",
      "Olympiakosz Pireusz":"ucl_crest/olympiacos.png",
      "Slavia Praha":"ucl_crest/slavia.png",
      "Pafosz":"ucl_crest/pafos.png",
      "Paris Saint-Germain":"ucl_crest/psg.png",
      "Qarabag":"ucl_crest/qarabag.png",
      "Real Madrid":"ucl_crest/real.png",
      "Sporting CP":"ucl_crest/sporting.png",
      "Tottenham Hotspur":"ucl_crest/tottenham.png",
      "Union Saint-Gilloise":"ucl_crest/usg.png",
      "Villarreal":"ucl_crest/villareal.png",
      "Kajrat Almati":"ucl_crest/kairat.png",
      "PSV":"ucl_crest/psv.png"
    };

    let currentUserEmail = "";
    let currentUserNick = "";
    let currentUserRole = "user";
    let favouriteTeamucl = "";
    let chatLastSeen = null;

    const nickByEmail = {};
    let matches = [];
    let roundsAsc = [];
    let firstLegByMatchId = new Map(); // matchId -> {slotId, oddsHome, oddsAway, homeTeam, awayTeam, winner}
    let advanceTipsBySlot = new Map(); // slotId -> [tips]
    let baseStakeByRound = {}; // {"9":2, ...} (A opció)

    const tipsByMatch = new Map();

    function escapeHtml(s){
      return (s ?? "").toString()
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }
    function fmtTime(ts){
      try{ return ts.toDate().toLocaleString("hu-HU",{hour12:false}); }catch{ return ""; }
    }
    function parseRes(str){
      const m=String(str||"").match(/^\s*(\d+)\s*-\s*(\d+)\s*$/);
      return m?[parseInt(m[1]),parseInt(m[2])]:null;
    }
    function canonTeam(t){ return (t||"").toString().trim(); }
    function fmt(n){ return (Number(n)||0).toFixed(2).replace(/\.00$/,""); }

    function tipChoice(t){
      return (t.choice ?? t.pick ?? t.tip ?? t.selection ?? "").toString().trim();
    }
    function tipDouble(t){
      return !!(t.double ?? t.isDouble ?? t.dupla ?? false);
    }

    function getOdds(m, pick){
      if (!m) return null;
      if (pick === "1") return m.oddsHome ?? m.odds1 ?? null;
      if (pick === "X") return m.oddsDraw ?? m.oddsX ?? null;
      if (pick === "2") return m.oddsAway ?? m.odds2 ?? null;
      return null;
    }

    function getBaseStake(roundId){
      const r = String(roundId ?? "");
      const v = baseStakeByRound && Object.prototype.hasOwnProperty.call(baseStakeByRound, r) ? Number(baseStakeByRound[r]) : 1;
      return (v && v > 0) ? v : 1;
    }

    function effectiveMatchMultiplier(roundId, tipObj){
      const r = Number(roundId ?? 0);
      const stake = getBaseStake(r);
      if (r >= 9) return 1 * stake;
      return (tipDouble(tipObj) ? 2 : 1) * stake;
    }

    function resolveAdvanceWinnerFromSlot(slot){
      const aw = (slot.advanceWinner || "").toString().trim();
      if (aw === "home" || aw === "away") return aw;
      const decided = (slot.decidedBy || "").toString().trim();
      const byPens = !!slot.decidedByPenalties || decided === "pens";
      const pw = (slot.penaltyWinner || "").toString().trim();
      if (byPens && (pw === "home" || pw === "away")) return pw;
      return "";
    }

    async function loadBaseStakes(){
      baseStakeByRound = {};
      try{
        const snap = await getDoc(doc(db,"settings","ucl_round_stakes"));
        if(snap.exists()){
          const d = snap.data() || {};
          const m = (d.baseStakeA && typeof d.baseStakeA === "object") ? d.baseStakeA : (d.baseStakes && typeof d.baseStakes === "object" ? d.baseStakes : {});
          for(const k of Object.keys(m||{})){
            const n = Number(m[k]);
            if(n && n > 0) baseStakeByRound[String(k)] = n;
          }
        }
      }catch(e){
        baseStakeByRound = {};
      }
    }

    async function loadBracketFirstLegs(){
      firstLegByMatchId.clear();
      try{
        const snap = await getDoc(doc(db,"settings","ucl_bracket"));
        const data = snap.exists() ? (snap.data()||{}) : {};
        const slots = (data.slots && typeof data.slots === "object") ? data.slots : {};
        Object.keys(slots).forEach(slotId=>{
          const s = slots[slotId] || {};
          const matchIds = Array.isArray(s.matchIds) ? s.matchIds : [];
          const firstLegId = matchIds[0] ? String(matchIds[0]) : "";
          if(!firstLegId) return;

          const oh = Number((s.advanceOddsHome===0 || s.advanceOddsHome) ? s.advanceOddsHome : NaN);
          const oa = Number((s.advanceOddsAway===0 || s.advanceOddsAway) ? s.advanceOddsAway : NaN);
          const oddsHome = (oh && oh > 1) ? oh : null;
          const oddsAway = (oa && oa > 1) ? oa : null;

          const homeTeam = s.homeTeam || "";
          const awayTeam = s.awayTeam || "";
          const winner = resolveAdvanceWinnerFromSlot(s);

          firstLegByMatchId.set(firstLegId, {
            slotId: String(slotId),
            oddsHome,
            oddsAway,
            homeTeam,
            awayTeam,
            winner
          });
        });
      }catch(e){}
    }

    async function loadAdvanceTipsAll(){
      advanceTipsBySlot.clear();
      try{
        const snap = await getDocs(collection(db,"ucl_advance_tips"));
        const latest = new Map(); // user|slot -> tip
        snap.forEach(d=>{
          const raw = d.data() || {};
          const t = { id:d.id, ...raw, user: raw.user || raw.email };
          const slotId = (t.slotId || t.slot || "").toString();
          if(!t.user || !slotId) return;
          const k = t.user + "|" + slotId;
          const cur = latest.get(k);
          const curTs = cur?.updatedAt?.toMillis?.() || cur?.createdAt?.toMillis?.() || cur?.timestamp?.toMillis?.() || 0;
          const ts = t.updatedAt?.toMillis?.() || t.createdAt?.toMillis?.() || t.timestamp?.toMillis?.() || 0;
          if(!cur || ts >= curTs) latest.set(k, t);
        });

        for(const tip of latest.values()){
          const slotId = (tip.slotId || tip.slot || "").toString();
          if(!advanceTipsBySlot.has(slotId)) advanceTipsBySlot.set(slotId, []);
          advanceTipsBySlot.get(slotId).push(tip);
        }
      }catch(e){}
    }

    function hiddenInfo(text){
      const box = document.createElement("div");
      box.className = "hiddenbox";
      box.textContent = text;
      return box;
    }
    function kicker(text){
      const d = document.createElement("div");
      d.className = "kicker";
      d.textContent = text;
      return d;
    }

    function deriveRounds(ms){
      const s = new Set();
      ms.forEach(m=>{
        const r = Number(m.roundId ?? m.round ?? 0);
        if (r) s.add(r);
      });
      return [...s].sort((a,b)=>a-b);
    }

    function renderRound(roundId){
      const now = new Date();
      const list = matches.filter(m => String(Number(m.roundId ?? m.round ?? 0)) === String(roundId))
        .sort((a,b)=>{
          const ta=a.startTime?.toDate?.()?.getTime?.()||0;
          const tb=b.startTime?.toDate?.()?.getTime?.()||0;
          return ta-tb;
        });

      const wrap = document.getElementById("roundWrap");
      wrap.innerHTML = "";

      const summary = {};
      const breakdown = {};

      list.forEach(m=>{
        const mTips = tipsByMatch.get(m.id) || [];
        const out = (m.outcome || "").toString().trim();
        if(!out) return;

        mTips.forEach(t=>{
          const pick = tipChoice(t);
          if(!pick) return;

          const correct = pick === out;
          const mult = effectiveMatchMultiplier(roundId, t);
          const ov = getOdds(m, pick);
          const pts = (correct && ov) ? Number(ov) * mult : 0;

          const nick = nickByEmail[t.user] || t.user || "Ismeretlen";
          summary[nick] = (summary[nick]||0) + pts;
          (breakdown[nick] ||= []).push(`Meccs: ${m.homeTeam}–${m.awayTeam}: ${pick} → ${fmt(pts)} pont`);
        });
      });

      // + Továbbjutó tippek pontozása (kieséses szakasz első meccseinél)
      list.forEach(m=>{
        const ko = m.startTime?.toDate?.();
        const hasStarted = ko && ko <= now;
        if(!hasStarted) return;

        const advInfo = firstLegByMatchId.get(String(m.id));
        if(!advInfo) return;

        const winner = (advInfo.winner || "").toString().trim();
        if(winner !== "home" && winner !== "away") return;

        const slotId = String(advInfo.slotId || "");
        if(!slotId) return;

        const slotTips = advanceTipsBySlot.get(slotId) || [];
        const stake = getBaseStake(roundId);

        slotTips.forEach(t=>{
          const pick = (t.pick || t.choice || t.selection || "").toString().trim();
          const correct = pick && (pick === winner);
          const ov = pick === "home" ? advInfo.oddsHome : (pick === "away" ? advInfo.oddsAway : null);
          const pts = (correct && ov) ? Number(ov) * stake : 0;

          const nick = nickByEmail[t.user] || t.user || "Ismeretlen";
          summary[nick] = (summary[nick]||0) + pts;

          const homeName = canonTeam(advInfo.homeTeam || m.homeTeam);
          const awayName = canonTeam(advInfo.awayTeam || m.awayTeam);
          const pickedTeam = pick === "home" ? homeName : (pick === "away" ? awayName : "—");
          const winnerTeam = winner === "home" ? homeName : awayName;

          (breakdown[nick] ||= []).push(`Továbbjutó: ${homeName}–${awayName}: ${pickedTeam} (nyert: ${winnerTeam}) → ${fmt(pts)} pont`);
        });
      });

      const summaryDiv = document.createElement("div");
      summaryDiv.className = "match";

      const sumRows = Object.keys(summary)
        .map(nick => ({nick, pts: summary[nick]}))
        .sort((a,b)=>b.pts-a.pts);

      summaryDiv.innerHTML = `
        <div class="sum">
          <div class="pill">
            <strong>Forduló összesítés</strong>
            <span class="badge">kör: ${escapeHtml(String(roundId))}</span>
          </div>
          <small class="muted">Meccspont + továbbjutó pont együtt</small>
        </div>
        <div class="divider"></div>
        ${sumRows.length ? sumRows.map(r=>`<div class="tip"><b>${escapeHtml(r.nick)}</b><span><b>${fmt(r.pts)}</b> pont</span></div>`).join("") : `<div class="kicker">Még nincs pontszám (nincs outcome / továbbjutó rögzítve).</div>`}
      `;
      wrap.appendChild(summaryDiv);

      list.forEach(m=>{
        const div = document.createElement("div");
        div.className = "match";
        const ko = m.startTime?.toDate?.();
        const hasStarted = ko && ko <= now;

        const head = document.createElement("div");
        head.className = "match-head";
        const result = (m.result || "").toString().trim();
        const outcome = (m.outcome || "").toString().trim();

        head.innerHTML = `
          <div>
            <div class="teams">${escapeHtml(m.homeTeam)} – ${escapeHtml(m.awayTeam)}</div>
            <div class="meta">${ko ? ko.toLocaleString("hu-HU",{hour12:false}) : ""} • kör: ${escapeHtml(String(roundId))}</div>
          </div>
          <div style="text-align:right">
            <div class="score">${result ? escapeHtml(result) : "—"}</div>
            <div class="meta">Outcome: ${outcome ? `<b>${escapeHtml(outcome)}</b>` : "—"}</div>
          </div>
        `;
        div.appendChild(head);

        const grid = document.createElement("div");
        grid.className = "subgrid";

        const tipsWrap = document.createElement("div");
        tipsWrap.className = "tips";
        tipsWrap.appendChild(kicker("Meccstippek"));

        const mTips = tipsByMatch.get(m.id) || [];

        if (!mTips.length){
          tipsWrap.appendChild(kicker("Ehhez a meccshez még nincs leadott tipp."));
        } else if (!hasStarted){
          tipsWrap.appendChild(hiddenInfo("A tippek a kezdésig nem nyilvánosak."));
          mTips.filter(t => t.user === currentUserEmail).forEach(t=>{
            const row = document.createElement("div");
            row.className = "tip";
            row.innerHTML = `<b>Saját tipped</b>: ${escapeHtml(tipChoice(t))}${(Number(roundId)<9 && tipDouble(t)) ? ' <span class="kicker">(dupla)</span>' : ''}`;
            tipsWrap.appendChild(row);
          });

          if (currentUserRole === "admin"){
            const uNames = [...new Set(mTips.map(t => t.user).filter(Boolean))]
              .map(e => escapeHtml(nickByEmail[e] || e));
            const adminRow = document.createElement("div");
            adminRow.className = "kicker";
            adminRow.innerHTML = `<b>Leadott tippek (admin):</b> ${uNames.length ? uNames.join(", ") : "—"} (${uNames.length} fő)`;
            tipsWrap.appendChild(adminRow);
          }
        } else {
          mTips.forEach(t=>{
            const pick = tipChoice(t);
            const correct = outcome ? pick === outcome : false;
            const mult = effectiveMatchMultiplier(roundId, t);
            const ov = getOdds(m, pick);
            const pts = (correct && ov) ? Number(ov) * mult : 0;

            const nick = nickByEmail[t.user] || t.user || "Ismeretlen";

            const row = document.createElement("div");
            row.className = "tip";
            if (outcome){
              if (correct) row.classList.add("correct");
              else row.classList.add("wrong");
            }
            row.innerHTML = `
              <b>${escapeHtml(nick)}</b>: ${escapeHtml(pick)}
              ${(Number(roundId)<9 && tipDouble(t)) ? ' <span class="kicker">(dupla)</span>' : ''}
              ${outcome ? ` – Pont: <b>${fmt(pts)}</b>` : ""}
            `;
            tipsWrap.appendChild(row);
          });
        }

        // Továbbjutó tipp szekció (csak az adott párharc első meccsénél)
        const advInfo = firstLegByMatchId.get(String(m.id));
        if (advInfo){
          const advBox = document.createElement("div");
          advBox.className = "tips";
          advBox.style.marginTop = "10px";

          const homeName = canonTeam(advInfo.homeTeam || m.homeTeam);
          const awayName = canonTeam(advInfo.awayTeam || m.awayTeam);
          const oh = advInfo.oddsHome ? String(advInfo.oddsHome) : "-";
          const oa = advInfo.oddsAway ? String(advInfo.oddsAway) : "-";

          const head = document.createElement("div");
          head.className = "kicker";
          head.innerHTML = `<b>Továbbjutó tipp</b> (${escapeHtml(homeName)} / ${escapeHtml(awayName)}) • odds: H ${escapeHtml(oh)} / V ${escapeHtml(oa)} • alaptét: ${escapeHtml(String(getBaseStake(roundId)))}`;
          advBox.appendChild(head);

          const slotId = String(advInfo.slotId || "");
          const slotTips = advanceTipsBySlot.get(slotId) || [];

          if (!slotTips.length){
            advBox.appendChild(kicker("Ehhez a párharc-továbbjutóhoz még nincs leadott tipp."));
          } else if (!hasStarted){
            advBox.appendChild(hiddenInfo("A továbbjutó tippek a kezdésig nem nyilvánosak."));
            slotTips.filter(t => t.user === currentUserEmail).forEach(t=>{
              const pick = (t.pick || "").toString().trim();
              const pickedTeam = pick === "home" ? homeName : (pick === "away" ? awayName : "—");
              const row = document.createElement("div");
              row.className = "tip";
              row.innerHTML = `<b>Saját továbbjutó tipped</b>: ${escapeHtml(pickedTeam)}`;
              advBox.appendChild(row);
            });

            if (currentUserRole === "admin"){
              const uNames = [...new Set(slotTips.map(t => t.user).filter(Boolean))]
                .map(e => escapeHtml(nickByEmail[e] || e));
              const adminRow = document.createElement("div");
              adminRow.className = "kicker";
              adminRow.innerHTML = `<b>Leadott továbbjutó tippek (admin):</b> ${uNames.length ? uNames.join(", ") : "—"} (${uNames.length} fő)`;
              advBox.appendChild(adminRow);
            }
          } else {
            const winner = (advInfo.winner || "").toString().trim();
            const winnerTeam = winner === "home" ? homeName : (winner === "away" ? awayName : "");
            const stake = getBaseStake(roundId);

            slotTips.forEach(t=>{
              const pick = (t.pick || "").toString().trim();
              const correct = (winner === "home" || winner === "away") ? (pick === winner) : false;
              const ov = pick === "home" ? advInfo.oddsHome : (pick === "away" ? advInfo.oddsAway : null);
              const pts = (correct && ov) ? Number(ov) * stake : 0;

              const nick = nickByEmail[t.user] || t.user || "Ismeretlen";
              const pickedTeam = pick === "home" ? homeName : (pick === "away" ? awayName : "—");

              const row = document.createElement("div");
              row.className = "tip";
              if (correct) row.classList.add("correct");
              else if (winner) row.classList.add("wrong");

              row.innerHTML = `
                <b>${escapeHtml(nick)}</b>: ${escapeHtml(pickedTeam)}
                ${winner ? ` – Továbbjutó: <b>${escapeHtml(winnerTeam || "—")}</b>` : ""}
                ${winner ? ` – Pont: <b>${fmt(pts)}</b>` : ""}
              `;
              advBox.appendChild(row);
            });
          }

          div.appendChild(advBox);
        }

        div.appendChild(tipsWrap);

        const expl = document.createElement("div");
        expl.className = "tips";
        expl.appendChild(kicker("Részletek / breakdown"));
        const any = Object.keys(breakdown).length > 0;
        if(!any){
          expl.appendChild(kicker("Nincs még breakdown (nincs outcome / továbbjutó)."));
        }else{
          Object.keys(breakdown).forEach(n=>{
            const rows = breakdown[n] || [];
            if(!rows.length) return;
            const box = document.createElement("div");
            box.style.marginTop = "10px";
            box.innerHTML = `<div class="kicker"><b>${escapeHtml(n)}</b></div>` + rows.map(x=>`<div class="kicker">• ${escapeHtml(x)}</div>`).join("");
            expl.appendChild(box);
          });
        }

        grid.appendChild(expl);
        div.appendChild(grid);

        wrap.appendChild(div);
      });
    }

    async function loadUsers(){
      Object.keys(nickByEmail).forEach(k=>delete nickByEmail[k]);
      try{
        const snap = await getDocs(collection(db,"users"));
        snap.forEach(d=>{
          const u = d.data() || {};
          const email = d.id;
          nickByEmail[email] = u.nickname || email;
        });
      }catch(e){}
    }

    function populateRoundSelect(){
      const sel = document.getElementById("roundSelect");
      sel.innerHTML = roundsAsc.map(r=>`<option value="${r}">${r}. forduló</option>`).join("");
      if (roundsAsc.length) sel.value = String(roundsAsc[roundsAsc.length-1]);
    }

    document.addEventListener("DOMContentLoaded", ()=>{
      initLeagueSwitcher({ mountTarget: document.getElementById("leagueSwitchMount") });
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) { window.location.href = "login.html"; return; }
      currentUserEmail = user.email;

      const userRef = doc(db, "users", currentUserEmail);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists()) {
        const d = userSnap.data();
        currentUserNick = d.nickname || currentUserEmail;
        currentUserRole = d.role || "user";
        favouriteTeamucl = d.favouriteTeamucl || "";
        chatLastSeen = d.chatLastSeenUcl || null;
      } else {
        currentUserNick = currentUserEmail;
        currentUserRole = "user";
        favouriteTeamucl = "";
        chatLastSeen = null;
      }
      document.getElementById("welcome").textContent = `Üdv, ${currentUserNick}!`;
      if (currentUserRole === "admin") document.getElementById("adminLink").style.display = "inline-flex";

      if (favouriteTeamucl) {
        const themeClass = "theme-" + favouriteTeamucl.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]+/g,"-");
        document.body.classList.add(themeClass);
        const crest = crestMap[favouriteTeamucl];
        if (crest) {
          const img = document.getElementById("favCrest");
          img.src = crest;
          img.hidden = false;
          img.alt = favouriteTeamucl;
        }
      }

      await loadUsers();

      const msSnap = await getDocs(collection(db,"ucl_matches"));
      matches = msSnap.docs.map(d=>({id:d.id, ...d.data()}));
      roundsAsc = deriveRounds(matches);
      populateRoundSelect();

      onSnapshot(collection(db,"ucl_matches"), snap=>{
        matches = snap.docs.map(d=>({id:d.id, ...d.data()}));
        roundsAsc = deriveRounds(matches);
        populateRoundSelect();
        const sel = document.getElementById("roundSelect");
        if (sel?.value) renderRound(sel.value);
      });

      tipsByMatch.clear();
      const tipsSnapAll = await getDocs(collection(db,'ucl_tips'));
      const latest = new Map();
      tipsSnapAll.forEach(docu=>{
        const t = docu.data() || {};
        const user = t.user || t.email || t.uid || "";
        const matchId = t.matchId || "";
        if (!user || !matchId) return;
        const k = user + "|" + matchId;
        const cur = latest.get(k);
        const curTs = cur?.updatedAt?.toMillis?.() || cur?.timestamp?.toMillis?.() || 0;
        const ts = t.updatedAt?.toMillis?.() || t.timestamp?.toMillis?.() || 0;
        if (!cur || ts >= curTs) latest.set(k, { ...t, user, matchId });
      });
      for (const tip of latest.values()){
        if (!tipsByMatch.has(tip.matchId)) tipsByMatch.set(tip.matchId, []);
        tipsByMatch.get(tip.matchId).push(tip);
      }

      await loadBaseStakes();
      await loadBracketFirstLegs();
      await loadAdvanceTipsAll();

      try{
        onSnapshot(doc(db,"settings","ucl_round_stakes"), async ()=>{ await loadBaseStakes(); const sel=document.getElementById("roundSelect"); if(sel?.value) renderRound(sel.value); });
      }catch(e){}
      try{
        onSnapshot(doc(db,"settings","ucl_bracket"), async ()=>{ await loadBracketFirstLegs(); const sel=document.getElementById("roundSelect"); if(sel?.value) renderRound(sel.value); });
      }catch(e){}
      try{
        onSnapshot(collection(db,"ucl_advance_tips"), async ()=>{ await loadAdvanceTipsAll(); const sel=document.getElementById("roundSelect"); if(sel?.value) renderRound(sel.value); });
      }catch(e){}

      const sel = document.getElementById("roundSelect");
      if (sel?.value) renderRound(sel.value);

      sel.addEventListener("change", ()=> renderRound(sel.value));

      document.getElementById("logout").addEventListener("click", ()=>{
        signOut(auth).then(()=>window.location.href="login.html");
      });

      if(window.hideLoader) hideLoader();
    });
  </script>
</head>

<body>
  <div class="layout">
    <div class="header">
      <div class="header-left">
        <img id="favCrest" class="fav-crest" alt="" hidden />
        <div>
          <h1>BL TippLiga – Eredmények</h1>
          <p id="welcome" class="welcome"></p>
        </div>
        <div id="leagueSwitchMount" aria-label="Tippjáték választó"></div>
      </div>
      <div class="row">
        <button id="logout" class="btn-accent" aria-label="Kilépés">
          <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M16 13v-2H7V7l-5 5 5 5v-4h9zm3-10H11a2 2 0 0 0-2 2v3h2V5h8v14h-8v-3H9v3a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2z"/></svg>
          Kilépés
        </button>
        <a href="dashboard_ucl.html" class="btn-accent" style="text-decoration:none">Vissza a főoldalra</a>
        <a id="adminLink" href="admin_ucl.html" class="btn-accent" style="text-decoration:none;display:none">Admin</a>
      </div>
    </div>

    <section class="card">
      <h3>Forduló kiválasztása</h3>
      <div class="body">
        <div class="row">
          <select id="roundSelect" class="select" aria-label="Forduló"></select>
          <span class="muted">Kezdés után látszanak a tippek. Továbbjutó tippek a párharc első meccsénél jelennek meg.</span>
        </div>
      </div>
    </section>

    <section class="card">
      <h3>Eredmények</h3>
      <div class="body">
        <div id="roundWrap" class="round"></div>
      </div>
    </section>
  </div>
</body>
</html>
