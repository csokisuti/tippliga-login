<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NB1 TippLiga – Statisztikák</title>
<style>
  :root{
    --bg:#f6f8fb; --card:#fff; --ink:#0f172a; --muted:#64748b; --line:#e6eaf1; --accent:#3b82f6;
    --good:#16a34a; --bad:#ef4444; --warn:#f59e0b;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,"Noto Sans",sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:20px;display:flex;flex-direction:column;gap:16px}
  .hdr{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .hdr h1{margin:0;font-size:24px}
  .sub{color:var(--muted)}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .sel,.btn{appearance:none;border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}
  .btn-ac{background:var(--accent);color:#fff;border-color:#dbeafe}
  .grid{display:grid;gap:14px}
  .two{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 22px rgba(15,23,42,.06);overflow:hidden}
  .card .head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--line);background:#f8faff}
  .card .title{font-weight:800}
  .card .muted{color:var(--muted);font-size:12px}
  .card .body{padding:12px}
  .kpi-row{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px}
  @media(max-width:900px){.kpi-row{grid-template-columns:repeat(2,minmax(0,1fr))}}
  .kpi{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px;display:flex;gap:10px;align-items:center}
  .kpi .val{font-size:22px;font-weight:800}
  .kpi .spark{height:32px;width:120px}
  table{width:100%;border-collapse:separate;border-spacing:0}
  th,td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;vertical-align:top}
  thead{background:#f7f9fd}
  .mini-leader .pos{width:28px;text-align:right;color:var(--muted)}
  .note{font-size:12px;color:var(--muted)}
  .tag{display:inline-block;background:#eef2ff;border:1px solid var(--line);padding:3px 8px;border-radius:999px;font-size:12px}
  .hl{background:#fff8e1;border:1px solid #fde68a}
  .qq{cursor:help; font-weight:700; margin-left:.35rem; color:#64748b}
  details{display:inline-block}
  details summary{list-style:none;cursor:pointer;display:inline-flex;align-items:center;gap:6px}
  details summary::after{content:"⌄";font-size:12px;opacity:.7}
  details[open] summary::after{transform:rotate(180deg)}
  .pill{display:inline-block;padding:2px 6px;border:1px solid var(--line);border-radius:999px;background:#f3f6ff;margin:2px 4px 0 0;font-size:12px}
  .form-inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .input{border:1px solid var(--line);border-radius:10px;padding:6px 10px}
  .stat{display:inline-block;min-width:90px}
  .bank-summary{margin-top:8px}
  .result-good{color:var(--good);font-weight:800}
  .result-bad{color:var(--bad);font-weight:800}
</style>
</head>
<body>
<div class="wrap">
  <header class="hdr">
    <div>
      <h1>NB1 TippLiga – Statisztikák</h1>
      <div class="sub">Éles Firestore-adatok. <strong>Az 1–3. forduló NEM számít</strong> (játék a 4.-től).</div>
    </div>
    <div class="toolbar">
      <select id="winSel" class="sel" title="Időablak">
        <option value="all" selected>Teljes szezon (F4-től)</option>
        <option value="5">Utolsó 5 forduló</option>
        <option value="10">Utolsó 10 forduló</option>
      </select>
      <select id="playerSel" class="sel" title="Játékos">
        <option value="all" selected>Összes játékos</option>
      </select>
      <select id="oddsSel" class="sel" title="Odds-szűrő">
        <option value="all" selected>Összes odds</option>
        <option value="low">Alacsony (≤1.8)</option>
        <option value="mid">Közepes (1.81–2.99)</option>
        <option value="high">Magas (≥3.0)</option>
      </select>
      <button id="exportBtn" class="btn btn-ac">Export CSV</button>
    </div>
  </header>

  <!-- Egyedi statok -->
  <section class="card">
    <div class="head">
      <div class="title">Egyedi statok</div>
      <div class="muted" id="whoLabel">Összes játékos</div>
    </div>
    <div class="body">
      <div class="kpi-row">
        <div class="kpi" title="Utolsó 5/10 forduló átlagpontja a kiválasztott időablakban. A vonal a trendet mutatja.">
          <div>
            <div class="muted">Forma-index<span class="qq">?</span></div>
            <div class="val" id="kpiForm">–</div>
            <div class="note">Pont / forduló</div>
          </div>
          <div class="spark" id="sparkForm"></div>
        </div>
        <div class="kpi" title="Dupla tippek találati aránya és a duplákból származó pontok aránya az összpontból.">
          <div style="flex:1 1 auto">
            <div class="muted">Duplázó-hatékonyság<span class="qq">?</span></div>
            <div class="val" id="kpiDouble">–</div>
            <div class="note" id="noteDouble">találat/összes • duplából jött pontok aránya</div>
          </div>
        </div>
        <div class="kpi" title="Átlagos választott odds (minden tipp) és a nyerő tippek átlagos oddsa.">
          <div style="flex:1 1 auto">
            <div class="muted">Kockázati profil<span class="qq">?</span></div>
            <div class="val" id="kpiRisk">–</div>
            <div class="note">Átlagos odds (nyerőknél is)</div>
          </div>
        </div>
        <div class="kpi" title="Hányszor találtad el a három kimenetel közül a legnagyobb oddsút (’upset’) és ezek átlaghozama.">
          <div style="flex:1 1 auto">
            <div class="muted">„Upset hunter” index<span class="qq">?</span></div>
            <div class="val" id="kpiUpset">–</div>
            <div class="note" id="noteUpset">ritka kimenetel találat + hozam</div>
          </div>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="head"><div class="title">Hazai / Döntetlen / Vendég bias<span class="qq" title="Milyen arányban választod az 1/X/2-t és ezek közül mennyi a találat.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Kimenetel</th><th>Választás</th><th>Találat</th></tr></thead>
              <tbody id="tableBias"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Csapatpreferencia és ROI<span class="qq" title="Mely csapatokra tippelsz a leggyakrabban, és mennyi pontot hoznak tipp/átlag alapon. X-nél mindkét csapat 0.5 tippel számol.">?</span></div><div class="muted">Top 5</div></div>
          <div class="body">
            <table>
              <thead><tr><th>Csapat</th><th>Tippek</th><th>Pts/Tipp</th></tr></thead>
              <tbody id="tableTeamRoi"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Bias index (kedvenc csapat)<span class="qq" title="A users.favoriteTeam alapján: hány tipp ment a kedvenc csapat meccseire, találati% és Pts/Tipp. Ha nincs beállítva, itt „—”.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Kedvenc csapat</th><th>Tippek</th><th>Találati %</th><th>Pts/Tipp</th></tr></thead>
              <tbody id="tableFavBias"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Odds-range teljesítmény<span class="qq" title="Odds sávokra bontva: tipp-szám, találati%, átlag pont és ROI (flat 1 egység/tipp).">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Sáv</th><th>Tippek</th><th>Találati %</th><th>Átlag pont</th><th>ROI</th></tr></thead>
              <tbody id="tableOddsRange"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Sportfogadás-mutató<span class="qq" title="Két szcenárió: (1) minden tipp 1 egység tét; (2) a duplának jelölt tippek 2 egységgel mennek. Profit = Visszafizetés − Össz-tét, ROI = Profit / Össz-tét.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Modell</th><th>Találati %</th><th>Össz-tét</th><th>Visszafizetés</th><th>Profit</th><th>ROI</th></tr></thead>
              <tbody id="tableBetSim"></tbody>
            </table>
            <div class="note">A pontszám továbbra is odds-alapú; ez a blokk illusztratív bankroll-szemlélet.</div>
          </div>
        </div>

        <!-- Bankroll-kalkulátor itt, Egyedi statok alatt -->
        <div class="card">
          <div class="head"><div class="title">Bankroll-kalkulátor<span class="qq" title="Ha minden saját tippedre X Ft-ot tettél volna a szűrt időablakban: össz-tét, visszafizetés, profit és ROI. A fenti Játékos szűrő szerint számol.">?</span></div></div>
          <div class="body">
            <div class="form-inline" style="margin-bottom:10px">
              <label>Játékos:</label>
              <select id="bankUserSel" class="input"></select>
              <label>Tét / tipp (Ft):</label>
              <input id="bankStake" class="input" type="number" min="1" step="100" value="1000"/>
              <button id="bankRecalcBtn" class="btn">Számol</button>
            </div>
            <!-- Feltűnő szöveg -->
            <div id="bankSummary" class="bank-summary">—</div>
            <!-- Részletek -->
            <div style="margin-top:6px">
              <span class="stat"><strong>Tippek:</strong> <span id="bankOutTips">–</span></span>
              <span class="stat"><strong>Össz-tét:</strong> <span id="bankOutStake">–</span> Ft</span>
              <span class="stat"><strong>Visszafizetés:</strong> <span id="bankOutReturn">–</span> Ft</span>
              <span class="stat"><strong>Profit:</strong> <span id="bankOutProfit">–</span> Ft</span>
              <span class="stat"><strong>ROI:</strong> <span id="bankOutRoi">–</span></span>
            </div>
            <div class="note" style="margin-top:6px">Számítás: flat modell (1 tét egy tippre), a megadott X Ft-tal skálázva.</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Összesített liga statok -->
  <section class="card">
    <div class="head"><div class="title">Összesített liga statok</div><div class="muted" id="rangeLabel">Teljes szezon (F4-től)</div></div>
    <div class="body">
      <!-- KÉRÉS: meglepetések és kimaradt ziccerek egymás mellett, legfelül -->
      <div class="grid two" style="margin-bottom:14px">
        <div class="card">
          <div class="head"><div class="title">Legnagyobb meglepetések (Top 5)<span class="qq" title="A legmagasabb nyertes oddsok a kiválasztott időablakban – csak ahol volt találó.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Meccs</th><th>Kimenetel</th><th>Odds</th><th>Találók</th></tr></thead>
              <tbody id="tableTopUpsets"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Kimaradt ziccerek (Top 5)<span class="qq" title="A legkisebb tippelt, de téves oddsok – ami ’könnyűnek’ tűnt, mégsem jött be.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Meccs</th><th>Tippelt kimenetel</th><th>Tipp odds</th><th>Rontók</th></tr></thead>
              <tbody id="tableMissedSitters"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="grid two">
        <div class="card">
          <div class="head"><div class="title">Tippeloszlás (1/X/2)<span class="qq" title="Összesen és fordulónként az 1/X/2 választási arány.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th></th><th>1</th><th>X</th><th>2</th></tr></thead>
              <tbody id="tablePickDist"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">„Bölcs tömeg” pontossága<span class="qq" title="Legnépszerűbb kimenetel találati aránya és átlag pont/meccs.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Metrika</th><th>Érték</th></tr></thead>
              <tbody id="tableCrowd"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">ROI toplista (flat 1 egység/tipp)<span class="qq" title="Profit = visszafizetés − tét. ROI = Profit / Tét.">?</span></div></div>
          <div class="body">
            <table class="mini-leader">
              <thead><tr><th class="pos">#</th><th>Játékos</th><th>Tippek</th><th>Találati %</th><th>Profit</th><th>ROI</th></tr></thead>
              <tbody id="tableRoiTop"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Odds-kalibráció<span class="qq" title="Implied P binelve vs valós gyakoriság.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>P (bin)</th><th>Várt %</th><th>Valós %</th><th>Eltérés</th></tr></thead>
              <tbody id="tableCalib"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Ponteloszlás fordulónként<span class="qq" title="Medián, P90, átlag pont fordulónként.">?</span></div></div>
          <div class="body">
            <table>
              <thead><tr><th>Forduló</th><th>Medián</th><th>P90</th><th>Átlag</th></tr></thead>
              <tbody id="tableRoundDist"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Gini az összpontban<span class="qq" title="0 = egyenlő; 1 = koncentrált.">?</span></div></div>
          <div class="body">
            <div id="giniVal" class="tag">Gini: –</div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // ====== CONFIG ======
  const firebaseConfig = {
    apiKey: "AIzaSyC2xpMW1xgaWIdI2JoEhK23vkC0FTF2PKc",
    authDomain: "tippliga-4b3af.firebaseapp.com",
    projectId: "tippliga-4b3af",
    storageBucket: "tippliga-4b3af.appspot.com",
    messagingSenderId: "720359845241",
    appId: "1:720359845241:web:d3d6edcac6b43ebff053a8"
  };
  const MIN_ROUND = 4;

  // ====== INIT ======
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  const $   = (id)=>document.getElementById(id);
  const fmt = (n)=> (Number(n)||0).toFixed(2);
  const s   = (v)=> (v==null ? "" : String(v));

  // Field helpers
  const tipChoice  = t => t?.choice ?? t?.tip ?? "";
  const tipDouble  = t => !!(t?.double ?? t?.isDouble);
  const matchRound = m => s(m?.round ?? m?.roundId ?? "");
  function roundNum(m){ const r = parseInt(matchRound(m),10); return isNaN(r)? null : r; }
  function getOdds(m, key){
    if (m?.odds && (key in m.odds)) return Number(m.odds[key]) || 0;
    if (key==="1") return Number(m?.odds1 ?? m?.["odds1"]) || 0;
    if (key==="X") return Number(m?.oddsX ?? m?.["oddsX"]) || 0;
    if (key==="2") return Number(m?.odds2 ?? m?.["odds2"]) || 0;
    return 0;
  }

  const state = { tips: [], matches: {}, users: {}, roundsAsc: [], perUserLatest: new Map() };

  onAuthStateChanged(auth, async () => {
    await loadAll();
    hydratePlayerSelect();
    recomputeAll();
    bindUi();
  });

  async function loadAll(){
    const [mSnap, tSnap, uSnap] = await Promise.all([
      getDocs(collection(db, "matches")),
      getDocs(collection(db, "tips")),
      getDocs(collection(db, "users"))
    ]);

    // matches (F4+)
    state.matches = {};
    mSnap.forEach(d => {
      const m = { id:d.id, ...d.data() };
      const rn = roundNum(m);
      if (rn==null || rn < MIN_ROUND) return;
      state.matches[d.id] = m;
    });

    // tips (latest per user×match for F4+)
    state.tips = tSnap.docs.map(d=> ({ id:d.id, ...d.data() }))
      .filter(t => s(t.user).trim() && s(t.matchId).trim());

    state.perUserLatest = new Map();
    for (const tip of state.tips){
      if (!state.matches[s(tip.matchId)]) continue;
      const k = `${s(tip.user)}|${s(tip.matchId)}`;
      const cur = state.perUserLatest.get(k);
      const curTs = cur?.updatedAt?.toMillis?.() || cur?.timestamp?.toMillis?.() || cur?.createdAt?.toMillis?.() || 0;
      const ts    = tip.updatedAt?.toMillis?.() || tip.timestamp?.toMillis?.() || tip.createdAt?.toMillis?.() || 0;
      if (!cur || ts >= curTs) state.perUserLatest.set(k, tip);
    }

    // users
    state.users = {};
    uSnap.forEach(d=>{
      const u=d.data();
      if(u?.email){
        state.users[u.email] = { nick: u.nickname || u.email, fav: u.favoriteTeam || "" };
      }
    });

    // rounds
    const rset = new Set();
    Object.values(state.matches).forEach(m=>{ const r = matchRound(m); if (r) rset.add(r); });
    state.roundsAsc = Array.from(rset).map(x=>parseInt(x,10)).sort((a,b)=>a-b).map(x=>String(x));
  }

  function hydratePlayerSelect(){
    const sel = $("playerSel");
    const map = new Map();
    for (const tip of state.perUserLatest.values()){
      const email = s(tip.user).trim(); if (!email) continue;
      const nick = state.users[email]?.nick || email;
      map.set(email, nick);
    }
    const ordered = [...map.entries()].sort((a,b)=> String(a[1]).localeCompare(String(b[1]), "hu", {sensitivity:"base"}));
    ordered.forEach(([email, nick])=>{ const o=document.createElement('option'); o.value=email; o.textContent=nick; sel.appendChild(o); });
  }

  function bindUi(){
    ["playerSel","winSel","oddsSel"].forEach(id=> $(id).addEventListener('change', recomputeAll));
    $("exportBtn").addEventListener('click', exportCsv);
    $("bankRecalcBtn").addEventListener('click', (e)=>{ e.preventDefault(); recomputeBankroll(); });
    $("bankStake").addEventListener('change', recomputeBankroll);
  }

  function currentFilters(){ return { player:$("playerSel").value, win:$("winSel").value, odds:$("oddsSel").value }; }
  function selectedRounds(){
    const { win } = currentFilters();
    let rounds = state.roundsAsc.slice();
    if (win !== 'all') rounds = rounds.slice(-parseInt(win,10));
    return rounds;
  }
  function tipPassesOddsChoice(o){
    const sel = $("oddsSel").value;
    if (!o) return false;
    if (sel === 'low') return o <= 1.8;
    if (sel === 'mid') return o > 1.8 && o < 3.0;
    if (sel === 'high') return o >= 3.0;
    return true;
  }
  function tipPassesOdds(t, m){
    const pick = tipChoice(t); if (!pick) return false;
    const o = getOdds(m, pick) || 0;
    return tipPassesOddsChoice(o);
  }

  // Per-player filter (respects playerSel)
  function filterTipsByUi(){
    const { player } = currentFilters();
    const rset = new Set(selectedRounds());
    const out = [];
    for (const tip of state.perUserLatest.values()){
      const email = s(tip.user).trim(); if (!email) continue;
      if (player!=='all' && email!==player) continue;
      const m = state.matches[s(tip.matchId)]; if (!m) continue;
      if (!rset.has(matchRound(m))) continue;
      if (!tipPassesOdds(tip, m)) continue;
      out.push(tip);
    }
    return out;
  }
  // League (ignores playerSel)
  function filterTipsForLeague(){
    const rset = new Set(selectedRounds());
    const out = [];
    for (const tip of state.perUserLatest.values()){
      const m = state.matches[s(tip.matchId)]; if (!m) continue;
      if (!rset.has(matchRound(m))) continue;
      if (!tipPassesOdds(tip, m)) continue;
      out.push(tip);
    }
    return out;
  }

  function recomputeAll(){
    const { player, win } = currentFilters();
    $("whoLabel").textContent  = (player==='all' ? 'Összes játékos' : (state.users[player]?.nick || player));
    $("rangeLabel").textContent= (win==='all' ? 'Teljes szezon (F4-től)' : `Utolsó ${win} forduló`);

    // ======= EGYEDI BLOKK =======
    const tips   = filterTipsByUi();
    const byUser = groupBy(tips, t=> s(t.user));
    const rds    = selectedRounds();

    // 1) user×round pontok előbb
    const perRoundPts = {};
    tips.forEach(t=>{
      const m = state.matches[s(t.matchId)]; if (!m) return;
      const pick = tipChoice(t); if (!pick) return;
      const ok   = !!m.outcome && pick===m.outcome;
      const mult = tipDouble(t) ? 2 : 1;
      const o    = getOdds(m, pick) || 0;
      const pts  = (ok && o) ? o*mult : 0;
      const r    = matchRound(m);
      (perRoundPts[t.user] ||= {});
      perRoundPts[t.user][r] = (perRoundPts[t.user][r]||0) + pts;
    });

    // 2) KPI aggregálók + bias + kedvenc csapat
    const bias={ '1':{pick:0,hit:0}, 'X':{pick:0,hit:0}, '2':{pick:0,hit:0} };
    let dblHit=0,dblAll=0,dblPts=0,basePts=0;
    let riskAll=0,riskWin=0, riskCountAll=0,riskCountWin=0;
    let upsetWins=0,upsetAll=0,upsetPts=0;
    const teamRoi=new Map();
    const rangeAgg = {
      low:   {name:'≤1.80', tips:0, wins:0, pts:0, stake:0, ret:0},
      mid1:  {name:'1.81–2.50', tips:0, wins:0, pts:0, stake:0, ret:0},
      mid2:  {name:'2.51–3.50', tips:0, wins:0, pts:0, stake:0, ret:0},
      high:  {name:'≥3.51', tips:0, wins:0, pts:0, stake:0, ret:0},
    };
    const bucket=(o)=> o<=1.8?'low':(o<=2.5?'mid1':(o<=3.5?'mid2':'high'));

    const favAgg = { team:'', tips:0, wins:0, pts:0 };
    if (player!=='all') favAgg.team = state.users[player]?.fav || '';

    tips.forEach(t=>{
      const m = state.matches[s(t.matchId)]; if (!m) return;
      const pick = tipChoice(t); if (!pick) return;
      const o    = getOdds(m, pick) || 0;
      const ok   = !!m.outcome && pick===m.outcome;
      const mult = tipDouble(t) ? 2 : 1;
      const pts  = (ok && o) ? o*mult : 0;

      // duplák + kockázat
      if (tipDouble(t)){ dblAll++; if (ok) dblHit++; if (pts) dblPts += pts; }
      basePts += pts;
      if (o){ riskAll+=o; riskCountAll++; if (ok){ riskWin+=o; riskCountWin++; } }

      // upset
      const maxO = Math.max(getOdds(m,'1')||0, getOdds(m,'X')||0, getOdds(m,'2')||0);
      if (o && Math.abs(o-maxO)<1e-9){ upsetAll++; if (ok){ upsetWins++; upsetPts += pts; } }

      // 1/X/2 bias
      bias[pick].pick++; if (ok) bias[pick].hit++;

      // Team ROI (X = 0.5-0.5)
      function addTeam(team, w){ const obj=teamRoi.get(team)||{tips:0,pts:0}; obj.tips+=w; obj.pts+=pts*w; teamRoi.set(team,obj); }
      if (pick==='1') addTeam(m.homeTeam||m.home||'',1);
      else if (pick==='2') addTeam(m.awayTeam||m.away||'',1);
      else if (pick==='X'){ addTeam(m.homeTeam||m.home||'',.5); addTeam(m.awayTeam||m.away||'',.5); }

      // Odds-range (flat modell)
      if (o){ const b = rangeAgg[bucket(o)]; b.tips++; if (ok){ b.wins++; b.pts+=pts; b.ret += o; } b.stake += 1; }

      // Kedvenc csapatos bias
      if (player!=='all' && favAgg.team){
        const isFavMatch = (s(m.homeTeam||m.home||'')===favAgg.team) || (s(m.awayTeam||m.away||'')===favAgg.team);
        if (isFavMatch){
          favAgg.tips += 1;
          if (ok) favAgg.wins += 1;
          favAgg.pts += pts;
        }
      }
    });

    // 3) Forma-index = átlag pont / forduló, a per-round sorozatokból
    const usersInView = (player==='all' ? Object.keys(byUser) : [player]);
    const sparkSeries = usersInView.map(u => rds.map(r => (perRoundPts[u]?.[r]||0)));
    const merged = mergeSeries(sparkSeries);
    const formAvg = merged.length ? (merged.reduce((a,b)=>a+b,0) / merged.length) : 0;
    $("kpiForm").textContent = `${fmt(formAvg)} / ford.`;
    drawSpark($("sparkForm"), merged);

    // 4) Egyéb KPI-k és táblák
    const dblRate = dblAll? (dblHit/dblAll*100):0;
    $("kpiDouble").textContent = dblAll? `${fmt(dblRate)}%` : '—';
    $("noteDouble").textContent = `${dblHit}/${dblAll} talált • duplából jött pontok: ${fmt(basePts? dblPts/basePts*100:0)}%`;

    $("kpiRisk").textContent = riskCountAll? `${fmt(riskAll/riskCountAll)} (nyerők: ${fmt(riskCountWin? riskWin/riskCountWin:0)})` : '—';
    $("kpiUpset").textContent = upsetAll? `${fmt(upsetWins/upsetAll*100)}%` : '—';
    $("noteUpset").textContent = `találat: ${upsetWins}/${upsetAll} • nyerő upset átlag: ${fmt(upsetWins? upsetPts/upsetWins:0)} pont`;

    fillBiasTable(bias);

    const topTeams = [...teamRoi.entries()].map(([team, o])=>({team, tips:o.tips, roi:o.tips? o.pts/o.tips:0}))
      .filter(x=>x.team).sort((a,b)=> b.roi - a.roi).slice(0,5);
    fillRows("tableTeamRoi", topTeams.map(x=>[`${x.team}`, fmt(x.tips), fmt(x.roi)]));

    const orows = Object.values(rangeAgg).map(b=>{
      const hit = b.tips ? b.wins/b.tips*100 : 0;
      const avg = b.tips ? b.pts/b.tips : 0;
      const roi = b.stake ? (b.ret - b.stake)/b.stake : 0;
      return [b.name, b.tips, fmt(hit)+'%', fmt(avg), fmt(roi)];
    });
    fillRows("tableOddsRange", orows);

    // Sportfogadás-mutató (egyedi)
    const totalTips = tips.length;
    let flatStake=0, flatReturn=0, correct=0, mixStake=0, mixReturn=0;
    tips.forEach(t=>{
      const m=state.matches[s(t.matchId)]; if(!m) return;
      const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome; const mult=tipDouble(t)?2:1;
      flatStake += 1; mixStake += mult;
      if (ok){ correct++; flatReturn += o; mixReturn += o*mult; }
    });
    const flatProfit = flatReturn-flatStake, mixProfit=mixReturn-mixStake;
    const flatRoi = flatStake? flatProfit/flatStake:0, mixRoi = mixStake? mixProfit/mixStake:0;
    const hitPct  = totalTips? correct/totalTips*100:0;
    fillRows("tableBetSim", [
      ['Flat 1 egység/tipp',     fmt(hitPct)+'%', fmt(flatStake), fmt(flatReturn), fmt(flatProfit), fmt(flatRoi)],
      ['Flat + duplák 2 egység', fmt(hitPct)+'%', fmt(mixStake),  fmt(mixReturn),  fmt(mixProfit),  fmt(mixRoi)]
    ]);

    // Bankroll dropdown feltöltés és számítás
    const bankSel = $("bankUserSel");
    const prevVal = bankSel.value;
    bankSel.innerHTML = "";
    const uniqUsers = [...new Set(tips.map(t=> s(t.user)))];
    uniqUsers
      .map(email => ({ email, nick: state.users[email]?.nick || email }))
      .sort((a,b)=> a.nick.localeCompare(b.nick, 'hu', {sensitivity:'base'}))
      .forEach(({email,nick})=>{ const o=document.createElement('option'); o.value=email; o.textContent=nick; bankSel.appendChild(o); });
    if (uniqUsers.length){
      if (uniqUsers.includes(prevVal)) bankSel.value = prevVal;
      else if (player!=='all' && uniqUsers.includes(player)) bankSel.value = player;
    }
    bankSel.onchange = recomputeBankroll;
    recomputeBankroll();

    // ---- Kedvenc csapat (Bias index) tábla tényleges kitöltése ----
    const favRows = [];
    if (player==='all' || !favAgg.team){
      favRows.push(['—','—','—','—']);
    } else {
      const hit = favAgg.tips ? favAgg.wins/favAgg.tips*100 : 0;
      const avg = favAgg.tips ? favAgg.pts/favAgg.tips : 0;
      favRows.push([favAgg.team, favAgg.tips, fmt(hit)+'%', fmt(avg)]);
    }
    fillRows("tableFavBias", favRows);

    // ======= LIGA BLOKK =======
    const tipsL   = filterTipsForLeague();
    const byUserL = groupBy(tipsL, t=> s(t.user));
    const byMatchL= groupBy(tipsL, t=> s(t.matchId));

    // Tippeloszlás
    let c1=0,cX=0,c2=0; const perRoundPick={};
    for (const t of tipsL){
      const m=state.matches[s(t.matchId)]; if(!m) continue; const r=matchRound(m);
      const p=tipChoice(t); if(!p) continue;
      if (p==='1') c1++; else if (p==='X') cX++; else if (p==='2') c2++;
      (perRoundPick[r] ||= {'1':0,'X':0,'2':0})[p]++;
    }
    const sum=c1+cX+c2 || 1;
    const pdRows=[[`Összesen`, fmt(c1/sum*100)+'%', fmt(cX/sum*100)+'%', fmt(c2/sum*100)+'%']];
    selectedRounds().forEach(r=>{ const o=perRoundPick[r]||{'1':0,'X':0,'2':0}; const ssum=o['1']+o['X']+o['2']||1; pdRows.push([`F${r}`, fmt(o['1']/ssum*100)+'%', fmt(o['X']/ssum*100)+'%', fmt(o['2']/ssum*100)+'%']); });
    fillRows("tablePickDist", pdRows, true);

    // Crowd pontosság
    let crowdWins=0,games=0,crowdPts=0,avgPts=0;
    for (const [mid, list] of Object.entries(byMatchL)){
      const m=state.matches[mid]; if(!m||!m.outcome) continue;
      const cnt={'1':0,'X':0,'2':0}; list.forEach(t=>{ const p=tipChoice(t); if(p) cnt[p]++; });
      const crowdPick = Object.entries(cnt).sort((a,b)=> b[1]-a[1])[0]?.[0] || '';
      if (!crowdPick) continue; games++;
      if (crowdPick===m.outcome) crowdWins++;
      let tot=0; list.forEach(t=>{ const p=tipChoice(t), mult=tipDouble(t)?2:1, o=getOdds(m,p)||0; const pts=(p===m.outcome && o)? o*mult:0; tot+=pts; });
      avgPts += (list.length? tot/list.length:0);
      const oC = getOdds(m,crowdPick)||0; if (crowdPick===m.outcome && oC) crowdPts += oC;
    }
    fillRows("tableCrowd", [
      ['Crowd-pick találati arány', fmt(games? crowdWins/games*100:0)+'%'],
      ['Átlag pont / meccs (valós)', fmt(games? avgPts/games:0)],
      ['Ha mindig crowd-pick lenne', fmt(games? crowdPts/games:0)],
    ]);

    // Legnagyobb meglepetések (Top 5) – csak ahol volt találó
    const upsetRows=[];
    for (const [mid, list] of Object.entries(byMatchL)){
      const m = state.matches[mid]; if (!m || !m.outcome) continue;
      const winO = getOdds(m, m.outcome) || 0; if (!winO) continue;
      const winners = list.filter(t=> tipChoice(t)===m.outcome);
      if (!winners.length) continue;
      upsetRows.push({
        mid, winO, winners,
        label: `${s(m.homeTeam||m.home||'?')} – ${s(m.awayTeam||m.away||'?')}`,
        outcome: m.outcome
      });
    }
    upsetRows.sort((a,b)=> b.winO - a.winO);
    const upRows = upsetRows.slice(0,5).map(u=>{
      const nicks = u.winners.map(w=> s(state.users[w.user]?.nick || w.user));
      const cell = `<details><summary>${nicks.length}</summary>${nicks.map(n=>`<span class="pill">${n}</span>`).join('')}</details>`;
      return [u.label, u.outcome, fmt(u.winO), cell];
    });
    fillRows("tableTopUpsets", upRows);

    // Kimaradt ziccerek (Top 5) – LEGKISEBB tippelt, de téves odds
    const missMap = new Map(); // key = mid|pick|odds → {mid,pick,o,users:Set}
    for (const [mid, list] of Object.entries(byMatchL)){
      const m = state.matches[mid]; if (!m || !m.outcome) continue;
      for (const t of list){
        const pick = tipChoice(t); if (!pick) continue;
        if (pick === m.outcome) continue; // csak téves tippek
        const o = getOdds(m, pick) || 0; if (!o) continue;
        const key = `${mid}|${pick}|${o.toFixed(3)}`;
        const rec = missMap.get(key) || { mid, pick, o, users: new Set() };
        rec.users.add(s(t.user));
        missMap.set(key, rec);
      }
    }
    const missed = [...missMap.values()].sort((a,b)=> a.o - b.o).slice(0,5);
    const missRows = missed.map(x=>{
      const m = state.matches[x.mid];
      const label = `${s(m?.homeTeam||m?.home||'?')} – ${s(m?.awayTeam||m?.away||'?')}`;
      const nicks = [...x.users].map(u=> s(state.users[u]?.nick || u));
      const cell = `<details><summary>${nicks.length}</summary>${nicks.map(n=>`<span class="pill">${n}</span>`).join('')}</details>`;
      return [label, x.pick, fmt(x.o), cell];
    });
    fillRows("tableMissedSitters", missRows);

    // ROI toplista (liga)
    const roiList = Object.keys(byUserL).map(u=>{
      const tipsU = byUserL[u];
      let stake=0, ret=0, wins=0;
      tipsU.forEach(t=>{
        const m = state.matches[s(t.matchId)]; if(!m) return;
        const p = tipChoice(t); const o = getOdds(m,p)||0; const ok = m.outcome && p===m.outcome;
        stake += 1; if (ok) { ret += o; wins++; }
      });
      const profit = ret - stake;
      const roi = stake ? profit/stake : 0;
      const hit = stake ? wins/stake*100 : 0;
      return { email:u, nick: state.users[u]?.nick || u, tips: stake, hit, profit, roi };
    }).sort((a,b)=> b.roi - a.roi).slice(0,10);

    fillRows("tableRoiTop", roiList.map((r,i)=>[
      `${i+1}.`, r.nick, r.tips, fmt(r.hit)+'%', fmt(r.profit), fmt(r.roi)
    ]));

    // Kalibráció
    const bins=[0,.2,.3,.4,.5,.6,.7,.8,1], stat=bins.slice(0,-1).map((b,i)=>({lo:b,hi:bins[i+1],exp:0,cnt:0}));
    const inRounds=new Set(selectedRounds());
    for (const m of Object.values(state.matches)){
      if (!inRounds.has(matchRound(m)) || !m.outcome) continue;
      const inv1=1/(getOdds(m,'1')||Infinity), invX=1/(getOdds(m,'X')||Infinity), inv2=1/(getOdds(m,'2')||Infinity);
      let ssum=0; [inv1,invX,inv2].forEach(v=>{ if (isFinite(v)) ssum+=v; }); if(!ssum) continue;
      const P={'1':inv1/ssum,'X':invX/ssum,'2':inv2/ssum}; const p=P[m.outcome]||0;
      const idx=stat.findIndex(b=> p>=b.lo && p<b.hi); if(idx>=0){ stat[idx].cnt++; stat[idx].exp += (stat[idx].lo+stat[idx].hi)/2; }
    }
    const total=stat.reduce((a,b)=>a+(b.cnt||0),0)||1;
    fillRows("tableCalib", stat.filter(b=>b.cnt).map(b=>[
      `${fmt(b.lo*100)}–${fmt(b.hi*100)}%`,
      fmt(b.exp/b.cnt*100)+'%',
      fmt(b.cnt/total*100)+'%',
      fmt(b.cnt/total*100 - (b.exp/b.cnt*100))+'pp'
    ]));

    // Ponteloszlás
    const perRoundPtsL = {};
    for (const [u, list] of Object.entries(byUserL)){
      list.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome; const mult=tipDouble(t)?2:1;
        const pts = (ok&&o)? o*mult:0; const r=matchRound(m);
        (perRoundPtsL[u] ||= {}); perRoundPtsL[u][r] = (perRoundPtsL[u][r]||0)+pts;
      });
    }
    const rdRows=[];
    selectedRounds().forEach(r=>{
      const arr = Object.keys(byUserL).map(u=> perRoundPtsL[u]?.[r]||0).sort((a,b)=>a-b);
      if (!arr.length) return;
      const med = quant(arr,.5), p90=quant(arr,.9), avg = arr.reduce((a,b)=>a+b,0)/arr.length;
      rdRows.push([`F${r}`, fmt(med), fmt(p90), fmt(avg)]);
    });
    fillRows("tableRoundDist", rdRows);

    // Gini
    const totalsL = Object.keys(byUserL).map(u=> Object.values(perRoundPtsL[u]||{}).reduce((a,b)=>a+b,0));
    $("giniVal").textContent = `Gini: ${fmt(gini(totalsL))}`;
  }

  function recomputeBankroll(){
    const tips = filterTipsByUi();
    const bankUser = $("bankUserSel").value;
    const X = Math.max(1, Number($("bankStake").value)||0);
    const list = tips.filter(t=> s(t.user)===bankUser);
    let tipsN=0, stake=0, ret=0, wins=0;
    list.forEach(t=>{
      const m = state.matches[s(t.matchId)]; if(!m) return;
      const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome;
      tipsN += 1; stake += X; if (ok){ wins++; ret += o*X; }
    });
    const profit = ret - stake;
    const roi = stake? profit/stake:0;

    $("bankOutTips").textContent = tipsN;
    $("bankOutStake").textContent = Math.round(stake);
    $("bankOutReturn").textContent = Math.round(ret);
    $("bankOutProfit").textContent = Math.round(profit);
    $("bankOutRoi").textContent = fmt(roi);

    const el = $("bankSummary");
    if (profit >= 0){
      el.className = "bank-summary result-good";
      el.textContent = `Ha minden tippedre ${X} Ft-ot tettél volna, összesen ${Math.round(profit)} Ft nyereséged lett volna, gratuláció!`;
    } else {
      el.className = "bank-summary result-bad";
      el.textContent = `Ha minden tippedre ${X} Ft-ot tettél volna, összesen ${Math.abs(Math.round(profit))} Ft veszteséged lett volna.`;
    }
  }

  // ===== helpers =====
  function groupBy(arr, fn){ const m={}; for(const x of arr){ const k=fn(x); (m[k] ||= []).push(x); } return m; }
  function quant(arr,q){ if(!arr.length) return 0; const p=(arr.length-1)*q; const i=Math.floor(p),f=p-i; if(!arr[i+1]) return arr[i]; return arr[i]*(1-f)+arr[i+1]*f; }
  function gini(values){ const v=values.slice().map(x=>Math.max(0,Number(x)||0)).sort((a,b)=>a-b); const n=v.length||1; const sum=v.reduce((a,b)=>a+b,0)||1; let acc=0; for(let i=0;i<n;i++) acc+=v[i]*(i+1); return (2*acc)/(n*sum) - (n+1)/n; }
  function mergeSeries(series){ if (!series.length) return []; const n=Math.max(...series.map(s=>s.length)); const out=[]; for(let i=0;i<n;i++){ let s=0,c=0; series.forEach(a=>{ if (i<a.length){ s+=a[i]; c++; } }); out.push(c? s/c:0); } return out; }
  function drawSpark(el, arr){
    if (!arr.length){ el.innerHTML=''; return; }
    const w=120,h=32, min=Math.min(...arr), max=Math.max(...arr);
    const sx=i=> (i/(Math.max(1,arr.length-1)))*(w-2)+1;
    const sy=v=>{ if(max===min) return h/2; const t=(v-min)/(max-min); return h-2 - t*(h-4); };
    let d=''; arr.forEach((v,i)=> d+=(i?' L':'M')+sx(i)+' '+sy(v));
    el.innerHTML=`<svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><path d="${d}" fill="none" stroke="var(--accent)" stroke-width="2"/></svg>`;
  }
  function fillRows(tbodyId, rows, highlightFirst=false){
    const tb=$(tbodyId); if (!tb) return;
    tb.innerHTML='';
    rows.forEach((r,i)=>{ const tr=document.createElement('tr'); if(highlightFirst && i===0) tr.className='hl'; tr.innerHTML=r.map(c=>`<td>${c}</td>`).join(''); tb.appendChild(tr); });
  }
  function fillBiasTable(b){
    const tb=$("tableBias"); tb.innerHTML='';
    [['1','Hazai'],['X','Döntetlen'],['2','Vendég']].forEach(([k,lab])=>{
      const p=b[k].pick, h=b[k].hit, sr=p? h/p*100:0;
      tb.appendChild(row([lab, p, fmt(sr)+'%']));
    });
    function row(cells){ const tr=document.createElement('tr'); tr.innerHTML=cells.map(c=>`<td>${c}</td>`).join(''); return tr; }
  }
  function exportCsv(){
    const tips = filterTipsByUi();
    const rows = [['user','matchId','round','home','away','pick','odds','double','correct','points']];
    for (const t of tips){
      const m=state.matches[String(t.matchId)]; if(!m) continue;
      const pick=tipChoice(t), o=getOdds(m,pick)||0, dbl=tipDouble(t);
      const ok=m.outcome && pick===m.outcome; const pts=(ok && o)? (dbl?2:1)*o:0;
      rows.push([t.user, t.matchId, matchRound(m), m.homeTeam||m.home||'', m.awayTeam||m.away||'', pick, o, dbl, ok, pts]);
    }
    const csv = rows.map(r=> r.map(x=>`"${String(x).replaceAll('"','""')}"`).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}); const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='nb1-stats-export.csv'; a.click(); URL.revokeObjectURL(url);
  }
</script>
</body>
</html>

