<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NB1 TippLiga – Statisztikák</title>
<style>
  :root{
    --bg:#f6f8fb; --card:#fff; --ink:#0f172a; --muted:#64748b; --line:#e6eaf1; --accent:#3b82f6;
    --good:#16a34a; --bad:#ef4444; --warn:#f59e0b;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,"Noto Sans",sans-serif}
  .wrap{max-width:1200px;margin:0 auto;padding:20px;display:flex;flex-direction:column;gap:16px}
  .hdr{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .hdr h1{margin:0;font-size:24px}
  .sub{color:var(--muted)}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .sel,.btn{appearance:none;border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}
  .sel-sm{padding:4px 6px;font-size:12px;border-radius:8px}
  .btn-ac{background:var(--accent);color:#fff;border-color:#dbeafe;text-decoration:none;display:inline-flex;align-items:center;gap:8px}
  .btn-icon{width:16px;height:16px;display:inline-block}
  .grid{display:grid;gap:14px}
  .two{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media(max-width:980px){.two{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 22px rgba(15,23,42,.06);overflow:hidden}
  .card .head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--line);background:#f8faff}
  .card .title{font-weight:800}
  .card .muted{color:var(--muted);font-size:12px}
  .card .body{padding:12px}
  .kpi-row{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px}
  @media(max-width:900px){.kpi-row{grid-template-columns:repeat(2,minmax(0,1fr))}}
  .kpi{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px;display:flex;gap:10px;align-items:center}
  .kpi .val{font-size:22px;font-weight:800}
  .kpi .spark{height:32px;width:120px}
  table{width:100%;border-collapse:separate;border-spacing:0}
  th,td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;vertical-align:top}
  thead{background:#f7f9fd}
  .mini-leader .pos{width:28px;text-align:right;color:var(--muted)}
  .note{font-size:12px;color:var(--muted)}
  .tag{display:inline-block;background:#eef2ff;border:1px solid var(--line);padding:3px 8px;border-radius:999px;font-size:12px}
  .hl{background:#fff8e1;border:1px solid #fde68a}
  /* kattintható ? gomb + buborék */
  .qq{display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;margin-left:6px;border:1px solid var(--line);border-radius:8px;background:#eef2ff;color:#374151;font-weight:900;cursor:pointer;user-select:none}
  .qq:focus{outline:2px solid color-mix(in oklab,var(--accent) 30%,white);outline-offset:2px}
  .help-pop{position:fixed;z-index:2000;max-width:280px;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 32px rgba(0,0,0,.15);padding:10px 12px;color:#111}
  .help-pop .close{position:absolute;top:6px;right:6px;border:1px solid var(--line);background:#eef2ff;border-radius:8px;cursor:pointer;width:22px;height:22px;display:inline-flex;align-items:center;justify-content:center}
  .pill{display:inline-block;padding:2px 6px;border:1px solid var(--line);border-radius:999px;background:#f3f6ff;margin:2px 4px 0 0;font-size:12px}
  .form-inline{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .input{border:1px solid var(--line);border-radius:10px;padding:6px 10px}
  .stat{display:inline-block;min-width:90px}
  .bank-summary{margin-top:8px}
  .result-good{color:var(--good);font-weight:800}
  .result-bad{color:var(--bad);font-weight:800}
  .nowrap{white-space:nowrap}
  .head .right{display:flex;align-items:center;gap:10px}
  .head .right label{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <header class="hdr">
    <div>
      <h1>NB1 TippLiga – Statisztikák</h1>
      <div class="sub">Éles Firestore-adatok. <strong>Az 1–3. forduló NEM számít</strong> (játék a 4.-től).</div>
    </div>
    <div class="toolbar">
      <a class="btn btn-ac" href="dashboard.html" title="Vissza a főoldalra">
        <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        Vissza
      </a>
      <select id="winSel" class="sel" title="Időablak">
        <option value="all" selected>Teljes szezon (F4-től)</option>
        <option value="5">Utolsó 5 forduló</option>
        <option value="10">Utolsó 10 forduló</option>
      </select>
      <select id="playerSel" class="sel" title="Játékos (mester)">
        <option value="all" selected>Összes játékos</option>
      </select>
      <select id="oddsSel" class="sel" title="Odds-szűrő">
        <option value="all" selected>Összes odds</option>
        <option value="low">Alacsony (≤1.8)</option>
        <option value="mid">Közepes (1.81–2.99)</option>
        <option value="high">Magas (≥3.0)</option>
      </select>
    </div>
  </header>

  <!-- Egyedi statok -->
  <section class="card">
    <div class="head">
      <div class="title">Egyedi statok <span class="qq" title="Személyre szűrt mutatók a kiválasztott időablakban. A Forma-indexnél váltható, hogy a duplák számítsanak-e.">?</span></div>
      <div class="muted" id="whoLabel">Összes játékos</div>
    </div>
    <div class="body">
      <div class="kpi-row">
        <div class="kpi">
          <div style="flex:1 1 auto">
            <div class="muted">Forma-index<span class="qq" title="Az egy fordulóra jutó átlagpont trendje. A kapcsolóval váltható, hogy a duplázás számítson-e.">?</span></div>
            <div class="val" id="kpiForm">–</div>
            <div class="note" style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <label>Játékos:</label>
              <select id="selFormUser" class="sel sel-sm userSel"></select>
              <label><input type="checkbox" id="chkFormDouble"> Duplázás számítson</label>
            </div>
          </div>
          <div class="spark" id="sparkForm"></div>
        </div>

        <div class="kpi">
          <div style="flex:1 1 auto">
            <div class="muted">Duplázó-hatékonyság<span class="qq" title="A duplának jelölt tippek találati aránya és az összpontból a duplák részesedése.">?</span></div>
            <div class="val" id="kpiDouble">–</div>
            <div class="note" id="noteDouble">találat/összes • duplából jött pontok aránya</div>
            <div class="note" style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <label>Játékos:</label>
              <select id="selDoubleUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
        </div>

        <div class="kpi">
          <div style="flex:1 1 auto">
            <div class="muted">Kockázati profil<span class="qq" title="Mekkora oddsokat választasz átlagosan, és mennyi az átlagodds a nyerő tippek között.">?</span></div>
            <div class="val" id="kpiRisk">–</div>
            <div class="note" style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <label>Játékos:</label>
              <select id="selRiskUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
        </div>

        <div class="kpi">
          <div style="flex:1 1 auto">
            <div class="muted">„Upset hunter” index<span class="qq" title="Hányszor választottad a legnagyobb oddsú kimenetelt, ezek találati aránya és átlaghozama. (Dupla NEM számít.)">?</span></div>
            <div class="val" id="kpiUpset">–</div>
            <div class="note" id="noteUpset">találat + hozam (sima)</div>
            <div class="note" style="display:flex;gap:8px;align-items:center;margin-top:4px">
              <label>Játékos:</label>
              <select id="selUpsetUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div class="head">
            <div class="title">Hazai / Döntetlen / Vendég bias
              <span class="qq" title="Milyen arányban választod az 1/X/2-t és ezek közül mennyi a találat.">?</span>
            </div>
            <div class="right">
              <label>Játékos:</label>
              <select id="selBiasUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Kimenetel</th><th>Választás</th><th>Találat</th></tr></thead>
              <tbody id="tableBias"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head">
            <div class="title">Csapatpreferencia és ROI
              <span class="qq" title="Mely csapatokra tippelsz a leggyakrabban, és mennyi pontot hoznak tipp/átlag alapon. X-nél mindkét csapat 0.5 tipp. Duplázás NEM számít.">?</span>
            </div>
            <div class="right">
              <label>Játékos:</label>
              <select id="selTeamRoiUser" class="sel sel-sm userSel"></select>
            </div>
            <div class="muted">Top 5</div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Csapat</th><th>Tippek</th><th>Pts/Tipp</th></tr></thead>
              <tbody id="tableTeamRoi"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head">
            <div class="title">Bias index (kedvenc csapat)
              <span class="qq" title="A users.favoriteTeam alapján: hány tipped ment a kedvenc csapat meccseire, találati% és Pts/Tipp.">?</span>
            </div>
            <div class="right">
              <label>Játékos:</label>
              <select id="selFavBiasUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Kedvenc csapat</th><th>Tippek</th><th>Találati %</th><th>Pts/Tipp</th></tr></thead>
              <tbody id="tableFavBias"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head">
            <div class="title">Odds-range teljesítmény
              <span class="qq" title="Odds sávokra bontva: tipp-szám, találati%, átlag pont és ROI (flat 1 egység/tipp). Duplázás NEM számít.">?</span>
            </div>
            <div class="right">
              <label>Játékos:</label>
              <select id="selOddsRangeUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Sáv</th><th>Tippek</th><th>Találati %</th><th>Átlag pont</th><th>ROI</th></tr></thead>
              <tbody id="tableOddsRange"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head">
            <div class="title">Sportfogadás-mutató
              <span class="qq" title="(1) Flat: minden tipp 1 egység tét. (2) Duplák: a duplának jelölt tippek 2 egység tét. Profit = Visszafizetés − Össz-tét, ROI = Profit / Össz-tét.">?</span>
            </div>
            <div class="right">
              <label>Játékos:</label>
              <select id="selBetSimUser" class="sel sel-sm userSel"></select>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Modell</th><th>Találati %</th><th>Össz-tét</th><th>Visszafizetés</th><th>Profit</th><th>ROI</th></tr></thead>
              <tbody id="tableBetSim"></tbody>
            </table>
            <div class="note">A pontszám továbbra is odds-alapú; ez a blokk illusztratív bankroll-szemlélet.</div>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Bankroll-kalkulátor
            <span class="qq" title="Ha minden saját tippedre X Ft-ot tettél volna a szűrt időablakban: össz-tét, visszafizetés, profit és ROI (flat modell).">?</span>
          </div></div>
          <div class="body">
            <div class="form-inline" style="margin-bottom:10px">
              <label>Játékos:</label>
              <select id="bankUserSel" class="input"></select>
              <label>Tét / tipp (Ft):</label>
              <input id="bankStake" class="input" type="number" min="1" step="100" value="1000"/>
              <button id="bankRecalcBtn" class="btn">Számol</button>
            </div>
            <div id="bankSummary" class="bank-summary">—</div>
            <div style="margin-top:6px">
              <span class="stat"><strong>Tippek:</strong> <span id="bankOutTips">–</span></span>
              <span class="stat"><strong>Össz-tét:</strong> <span id="bankOutStake">–</span> Ft</span>
              <span class="stat"><strong>Visszafizetés:</strong> <span id="bankOutReturn">–</span> Ft</span>
              <span class="stat"><strong>Profit:</strong> <span id="bankOutProfit">–</span> Ft</span>
              <span class="stat"><strong>ROI:</strong> <span id="bankOutRoi">–</span></span>
            </div>
            <div class="note" style="margin-top:6px">Számítás: flat modell (1 tét egy tippre), a megadott X Ft-tal skálázva.</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Összesített liga statok (változatlan) -->
  <section class="card">
    <div class="head"><div class="title">Összesített liga statok <span class="qq" title="A teljes, szűrt időablakra vonatkozó ligaszintű kimutatások.">?</span></div><div class="muted" id="rangeLabel">Teljes szezon (F4-től)</div></div>
    <div class="body">
      <div class="grid two" style="margin-bottom:14px">
        <div class="card">
          <div class="head">
            <div class="title">Legnagyobb meglepetések (Top 5)
              <span class="qq" title="A legnagyobb egyedi nyerések a nyertes odds alapján. Kapcsolóval: duplázás növelje-e a pontot (2× odds).">?</span>
            </div>
            <div class="right">
              <label><input type="checkbox" id="chkSurpriseDouble"> Duplázás számítson</label>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Játékos</th><th>Meccs</th><th>Kimenetel</th><th>Pont</th></tr></thead>
              <tbody id="tableTopSurprises"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Kimaradt ziccerek (Top 5)
            <span class="qq" title="A legkisebb tippelt, de téves oddsok – ami ’könnyűnek’ tűnt, mégsem jött be.">?</span>
          </div></div>
          <div class="body">
            <table>
              <thead><tr><th>Meccs</th><th>Tippelt kimenetel</th><th>Tipp odds</th><th>Rontók</th></tr></thead>
              <tbody id="tableMissedSitters"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="grid two" style="margin-bottom:14px">
        <div class="card">
          <div class="head">
            <div class="title">Forduló-győzelmek (db)
              <span class="qq" title="Azon fordulók száma, ahol a játékos a legtöbb pontot szerezte. Kapcsoló: duplázás beleszámítson-e a forduló pontjaiba.">?</span>
            </div>
            <div class="right">
              <label><input type="checkbox" id="chkRoundWinsDouble"> Duplázás számítson</label>
            </div>
          </div>
          <div class="body">
            <table>
              <thead><tr><th>Játékos</th><th>Győzelmek</th></tr></thead>
              <tbody id="tableRoundWins"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Upset hunter (felhasználók)
            <span class="qq" title="Felhasználónként: hányszor próbáltad a legnagyobb oddsú kimenetelt, ezek találati aránya és átlaghozama (dupla NEM számít).">?</span>
          </div><div class="muted">Dupla NEM számít</div></div>
          <div class="body">
            <table>
              <thead><tr><th>Játékos</th><th>Upset tippek</th><th>Találat</th><th>Találati %</th><th>Pts/Tipp</th></tr></thead>
              <tbody id="tableUpsetUsers"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Korai vs. késői tippek
            <span class="qq" title="A meccs kezdete előtt 6 óránál korábban leadott (korai) vs. későbbi (késői) tippek találati aránya. A végső leadási idővel számol.">?</span>
          </div><div class="muted">6 órás küszöb</div></div>
          <div class="body">
            <table>
              <thead><tr><th>Kategória</th><th>Tippek</th><th>Találati %</th></tr></thead>
              <tbody id="tableEarlyLate"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Sáv-nyerő (ROI)
            <span class="qq" title="Melyik odds-sáv hozta a legjobb ROI-t a ligában (flat 1 egység/tipp, dupla NEM számít).">?</span>
          </div></div>
          <div class="body">
            <div id="rangeWinnerVal" class="val">—</div>
            <div class="note">A legjobb odds-sáv az aktuális időablakban (dupla NEM számít).</div>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">A hét meccse
            <span class="qq" title="Az a meccs, ahol a játékosok átlagosan a legtöbb pontot szerezték. (Itt a duplák számítanak.)">?</span>
          </div><div class="muted">Az aktuális időablakban</div></div>
          <div class="body">
            <div class="kpi">
              <div style="flex:1 1 auto">
                <div id="matchOfWeekText">—</div>
                <div class="note">Átlag pont/tipp: <span id="matchOfWeekAvg">—</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Tippeloszlás (1/X/2)
            <span class="qq" title="Összesen és fordulónként az 1/X/2 választási arány a ligában.">?</span>
          </div></div>
          <div class="body">
            <table>
              <thead><tr><th></th><th>1</th><th>X</th><th>2</th></tr></thead>
              <tbody id="tablePickDist"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">ROI toplista (flat 1 egység/tipp)
            <span class="qq" title="Profit = visszafizetés − tét. ROI = Profit / Tét. Duplázás nem számít a tétbe.">?</span>
          </div></div>
          <div class="body">
            <table class="mini-leader">
              <thead><tr><th class="pos">#</th><th>Játékos</th><th>Tippek</th><th>Találati %</th><th>Profit</th><th>ROI</th></tr></thead>
              <tbody id="tableRoiTop"></tbody>
            </table>
          </div>
        </div>

        <div class="card">
          <div class="head"><div class="title">Tippmódosítások
            <span class="qq" title="Melyik meccsnél volt a legtöbb módosítás (felhasználók), és a módosított tippek végül milyen arányban jöttek be. A kimutatás az aktuális időablak meccseire készül.">?</span>
          </div></div>
          <div class="body">
            <div class="note" style="margin-bottom:6px">Módosított tippek találati aránya: <strong id="modHitRate">—</strong></div>
            <table>
              <thead><tr><th>Meccs</th><th>Módosítások</th><th>Felhasználók</th></tr></thead>
              <tbody id="tableMostModified"></tbody>
            </table>
          </div>
        </div>

      </div>
    </div>
  </section>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // ====== CONFIG ======
  const firebaseConfig = {
    apiKey: "AIzaSyC2xpMW1xgaWIdI2JoEhK23vkC0FTF2PKc",
    authDomain: "tippliga-4b3af.firebaseapp.com",
    projectId: "tippliga-4b3af",
    storageBucket: "tippliga-4b3af.appspot.com",
    messagingSenderId: "720359845241",
    appId: "1:720359845241:web:d3d6edcac6b43ebff053a8"
  };
  const MIN_ROUND = 4;

  // ====== INIT ======
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  const $   = (id)=>document.getElementById(id);
  const fmt = (n)=> (Number(n)||0).toFixed(2);
  const s   = (v)=> (v==null ? "" : String(v));

  // Field helpers
  const tipChoice  = t => t?.choice ?? t?.tip ?? "";
  const tipDouble  = t => !!(t?.double ?? t?.isDouble);
  const matchRound = m => s(m?.round ?? m?.roundId ?? "");
  function roundNum(m){ const r = parseInt(matchRound(m),10); return isNaN(r)? null : r; }

  // get odds by key
  function getOdds(m, key){
    if (m?.odds && (key in m.odds)) return Number(m.odds[key]) || 0;
    if (key==="1") return Number(m?.odds1 ?? m?.["odds1"]) || 0;
    if (key==="X") return Number(m?.oddsX ?? m?.["oddsX"]) || 0;
    if (key==="2") return Number(m?.odds2 ?? m?.["odds2"]) || 0;
    return 0;
  }
  // kickoff millis (best-effort)
  function getMatchStartMs(m){
    const cand = [m?.kickoff, m?.start, m?.startTime, m?.kickoffTime, m?.dateTime, m?.ts, m?.timestamp, m?.beginAt];
    for (const x of cand){
      const ms = x?.toMillis?.() || (typeof x==="number" ? x : (typeof x==="string" ? Date.parse(x) : 0));
      if (ms && !Number.isNaN(ms)) return ms;
    }
    if (m?.date && m?.time){
      const ms = Date.parse(`${m.date} ${m.time}`);
      if (!Number.isNaN(ms)) return ms;
    }
    return null;
  }
  // tip time millis (use latest edit)
  function getTipTimeMs(t){
    const cand = [t?.updatedAt, t?.timestamp, t?.createdAt, t?.ts, t?.modifiedAt];
    for (const x of cand){
      const ms = x?.toMillis?.() || (typeof x==="number" ? x : (typeof x==="string" ? Date.parse(x) : 0));
      if (ms && !Number.isNaN(ms)) return ms;
    }
    return 0;
  }

  const state = { tips: [], matches: {}, users: {}, roundsAsc: [], perUserLatest: new Map(), viewer:null };

  onAuthStateChanged(auth, async (u) => {
    state.viewer = u?.email || null;
    await loadAll();
    hydratePlayerSelect();
    populateAllUserDropdowns();
    setDefaultsFromViewer();
    bindUi();
    initHelpBubbles();
    recomputeAll();
  });

  async function loadAll(){
    const [mSnap, tSnap, uSnap] = await Promise.all([
      getDocs(collection(db, "matches")),
      getDocs(collection(db, "tips")),
      getDocs(collection(db, "users"))
    ]);

    // matches (F4+)
    state.matches = {};
    mSnap.forEach(d => {
      const m = { id:d.id, ...d.data() };
      const rn = roundNum(m);
      if (rn==null || rn < MIN_ROUND) return;
      state.matches[d.id] = m;
    });

    // tips (keep ALL versions + compute latest per user×match)
    state.tips = tSnap.docs.map(d=> ({ id:d.id, ...d.data() }))
      .filter(t => s(t.user).trim() && s(t.matchId).trim());

    state.perUserLatest = new Map();
    for (const tip of state.tips){
      if (!state.matches[s(tip.matchId)]) continue;
      const k = `${s(tip.user)}|${s(tip.matchId)}`;
      const cur = state.perUserLatest.get(k);
      const curTs = cur ? getTipTimeMs(cur) : 0;
      const ts    = getTipTimeMs(tip);
      if (!cur || ts >= curTs) state.perUserLatest.set(k, tip);
    }

    // users
    state.users = {};
    uSnap.forEach(d=>{
      const u=d.data();
      if(u?.email){
        state.users[u.email] = { nick: u.nickname || u.email, fav: u.favoriteTeam || "" };
      }
    });

    // rounds
    const rset = new Set();
    Object.values(state.matches).forEach(m=>{ const r = matchRound(m); if (r) rset.add(r); });
    state.roundsAsc = Array.from(rset).map(x=>parseInt(x,10)).sort((a,b)=>a-b).map(x=>String(x));
  }

  function hydratePlayerSelect(){
    const sel = $("playerSel");
    const map = new Map();
    for (const tip of state.perUserLatest.values()){
      const email = s(tip.user).trim(); if (!email) continue;
      const nick = state.users[email]?.nick || email;
      map.set(email, nick);
    }
    const ordered = [...map.entries()].sort((a,b)=> String(a[1]).localeCompare(String(b[1]), "hu", {sensitivity:"base"}));
    ordered.forEach(([email, nick])=>{ const o=document.createElement('option'); o.value=email; o.textContent=nick; sel.appendChild(o); });
  }

  function populateAllUserDropdowns(){
    const master = $("playerSel");
    const opts = [...master.options].map(o=> ({value:o.value, text:o.textContent}));
    document.querySelectorAll(".userSel").forEach(sel=>{
      sel.innerHTML = "";
      opts.forEach(({value,text})=>{
        const o=document.createElement('option'); o.value=value; o.textContent=text; sel.appendChild(o);
      });
    });
  }

  function setDefaultsFromViewer(){
    const master = $("playerSel");
    const def = (state.viewer && [...master.options].some(o=>o.value===state.viewer)) ? state.viewer : "all";
    master.value = def;
    syncUserSelectors(def);
  }

  function bindUi(){
    ["winSel","oddsSel"].forEach(id=> $(id).addEventListener('change', recomputeAll));
    // master player controls all locals
    $("playerSel").addEventListener('change', ()=>{
      syncUserSelectors($("playerSel").value);
      recomputeAll();
    });
    // local dropdowns just recompute
    document.querySelectorAll(".userSel").forEach(sel=> sel.addEventListener('change', recomputeAll));
    $("bankRecalcBtn").addEventListener('click', (e)=>{ e.preventDefault(); recomputeBankroll(); });
    $("bankStake").addEventListener('change', recomputeBankroll);
    ["chkSurpriseDouble","chkFormDouble","chkRoundWinsDouble"].forEach(id=>{
      const el=$(id); if (el) el.addEventListener('change', recomputeAll);
    });
  }

  function syncUserSelectors(val){
    document.querySelectorAll(".userSel").forEach(sel=> sel.value = val);
  }

  function currentFilters(){ return { win:$("winSel").value, odds:$("oddsSel").value }; }
  function selectedRounds(){
    const { win } = currentFilters();
    let rounds = state.roundsAsc.slice();
    if (win !== 'all') rounds = rounds.slice(-parseInt(win,10));
    return rounds;
  }
  function tipPassesOddsChoice(o){
    const sel = $("oddsSel").value;
    if (!o) return false;
    if (sel === 'low') return o <= 1.8;
    if (sel === 'mid') return o > 1.8 && o < 3.0;
    if (sel === 'high') return o >= 3.0;
    return true;
  }
  function tipPassesOdds(t, m){
    const pick = tipChoice(t); if (!pick) return false;
    const o = getOdds(m, pick) || 0;
    return tipPassesOddsChoice(o);
  }

  function filterTipsForUser(userVal){
    const rset = new Set(selectedRounds());
    const out = [];
    for (const tip of state.perUserLatest.values()){
      const email = s(tip.user).trim(); if (!email) continue;
      if (userVal!=='all' && email!==userVal) continue;
      const m = state.matches[s(tip.matchId)]; if (!m) continue;
      if (!rset.has(matchRound(m))) continue;
      if (!tipPassesOdds(tip, m)) continue;
      out.push(tip);
    }
    return out;
  }
  function filterTipsForLeague(){
    const rset = new Set(selectedRounds());
    const out = [];
    for (const tip of state.perUserLatest.values()){
      const m = state.matches[s(tip.matchId)]; if (!m) continue;
      if (!rset.has(matchRound(m))) continue;
      if (!tipPassesOdds(tip, m)) continue;
      out.push(tip);
    }
    return out;
  }

  function labelForUser(val){
    if (val==='all') return 'Összes játékos';
    return state.users[val]?.nick || val;
  }

  function recomputeAll(){
    const masterVal = $("playerSel").value;
    $("whoLabel").textContent = labelForUser(masterVal);
    const { win } = currentFilters();
    $("rangeLabel").textContent = (win==='all' ? 'Teljes szezon (F4-től)' : `Utolsó ${win} forduló`);

    const rds = selectedRounds();

    // ======= EGYEDI BLOKK – per kártya saját user =======
    // --- Forma-index ---
    (function(){
      const u = $("selFormUser").value || masterVal;
      const tips = filterTipsForUser(u);
      const byUser = groupBy(tips, t=> s(t.user));
      const perRoundPtsS = {}, perRoundPtsD = {};
      tips.forEach(t=>{
        const m = state.matches[s(t.matchId)]; if (!m) return;
        const p = tipChoice(t); if (!p) return;
        const ok = !!m.outcome && p===m.outcome;
        const o  = getOdds(m,p)||0;
        const r  = matchRound(m);
        const ptsS=(ok&&o)?o:0, ptsD=(ok&&o)?(tipDouble(t)?2:1)*o:0;
        (perRoundPtsS[t.user] ||= {}); (perRoundPtsD[t.user] ||= {});
        perRoundPtsS[t.user][r]=(perRoundPtsS[t.user][r]||0)+ptsS;
        perRoundPtsD[t.user][r]=(perRoundPtsD[t.user][r]||0)+ptsD;
      });
      const useD = !!$("chkFormDouble")?.checked;
      const usersInView = (u==='all' ? Object.keys(byUser) : [u]);
      const sparkSeries = usersInView.map(uu=>{
        const src = useD ? perRoundPtsD : perRoundPtsS;
        return rds.map(r => (src[uu]?.[r]||0));
      });
      const merged = mergeSeries(sparkSeries);
      const avg = merged.length ? (merged.reduce((a,b)=>a+b,0)/merged.length) : 0;
      $("kpiForm").textContent = `${fmt(avg)} / ford.`;
      drawSpark($("sparkForm"), merged);
    })();

    // helper to compute simple per-user aggregates
    function computeUserAgg(u){
      const tips = filterTipsForUser(u);
      const res = {
        tips, bias:{'1':{pick:0,hit:0},'X':{pick:0,hit:0},'2':{pick:0,hit:0}},
        dblHit:0,dblAll:0,dblPts:0,basePts:0,
        riskAll:0,riskWin:0, cAll:0,cWin:0,
        upsetWins:0,upsetAll:0,upsetPts:0,
        teamRoi:new Map(),
        rangeAgg:{low:{name:'≤1.80',tips:0,wins:0,ptsS:0,stake:0,ret:0},mid1:{name:'1.81–2.50',tips:0,wins:0,ptsS:0,stake:0,ret:0},mid2:{name:'2.51–3.50',tips:0,wins:0,ptsS:0,stake:0,ret:0},high:{name:'≥3.51',tips:0,wins:0,ptsS:0,stake:0,ret:0}}
      };
      const bucket=(o)=> o<=1.8?'low':(o<=2.5?'mid1':(o<=3.5?'mid2':'high'));
      tips.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const p=tipChoice(t); if(!p) return;
        const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome;
        const mult=tipDouble(t)?2:1;
        const pts=(ok&&o)? o*mult:0; const ptsS=(ok&&o)?o:0;
        if (tipDouble(t)){ res.dblAll++; if (ok) res.dblHit++; if (pts) res.dblPts+=pts; }
        res.basePts += pts;
        if (o){ res.riskAll+=o; res.cAll++; if (ok){ res.riskWin+=o; res.cWin++; } }
        const maxO = Math.max(getOdds(m,'1')||0,getOdds(m,'X')||0,getOdds(m,'2')||0);
        if (o && Math.abs(o-maxO)<1e-9){ res.upsetAll++; if (ok){ res.upsetWins++; res.upsetPts += ptsS; } }
        res.bias[p].pick++; if (ok) res.bias[p].hit++;
        function addTeam(team,w){ const obj=res.teamRoi.get(team)||{tips:0,ptsS:0}; obj.tips+=w; obj.ptsS+=ptsS*w; res.teamRoi.set(team,obj); }
        if (p==='1') addTeam(m.homeTeam||m.home||'',1);
        else if (p==='2') addTeam(m.awayTeam||m.away||'',1);
        else if (p==='X'){ addTeam(m.homeTeam||m.home||'',.5); addTeam(m.awayTeam||m.away||'',.5); }
        if (o){ const b=res.rangeAgg[bucket(o)]; b.tips++; if (ok){ b.wins++; b.ptsS+=ptsS; b.ret+=o; } b.stake+=1; }
      });
      return res;
    }

    // --- Duplázó-hatékonyság ---
    (function(){
      const u = $("selDoubleUser").value || masterVal;
      const a = computeUserAgg(u);
      const dblRate = a.dblAll? (a.dblHit/a.dblAll*100):0;
      $("kpiDouble").textContent = a.dblAll? `${fmt(dblRate)}%` : '—';
      $("noteDouble").textContent = `${a.dblHit}/${a.dblAll} talált • duplából jött pontok: ${fmt(a.basePts? a.dblPts/a.basePts*100:0)}%`;
    })();

    // --- Kockázati profil ---
    (function(){
      const u = $("selRiskUser").value || masterVal;
      const a = computeUserAgg(u);
      $("kpiRisk").textContent = a.cAll? `${fmt(a.riskAll/a.cAll)} (nyerők: ${fmt(a.cWin? a.riskWin/a.cWin:0)})` : '—';
    })();

    // --- Upset hunter ---
    (function(){
      const u = $("selUpsetUser").value || masterVal;
      const a = computeUserAgg(u);
      $("kpiUpset").textContent = a.upsetAll? `${fmt(a.upsetWins/a.upsetAll*100)}%` : '—';
      $("noteUpset").textContent = `találat: ${a.upsetWins}/${a.upsetAll} • nyerő upset átlag: ${fmt(a.upsetWins? a.upsetPts/a.upsetWins:0)} pont`;
    })();

    // --- Bias tábla ---
    (function(){
      const u = $("selBiasUser").value || masterVal;
      const a = computeUserAgg(u);
      fillBiasTable(a.bias);
    })();

    // --- Csapatpreferencia és ROI ---
    (function(){
      const u = $("selTeamRoiUser").value || masterVal;
      const a = computeUserAgg(u);
      const topTeams = [...a.teamRoi.entries()].map(([team, o])=>({team, tips:o.tips, roi:o.tips? o.ptsS/o.tips:0}))
        .filter(x=>x.team).sort((a,b)=> b.roi - a.roi).slice(0,5);
      fillRows("tableTeamRoi", topTeams.map(x=>[`${x.team}`, fmt(x.tips), fmt(x.roi)]));
    })();

    // --- Kedvenc csapat bias ---
    (function(){
      const u = $("selFavBiasUser").value || masterVal;
      const fav = state.users[u]?.fav || '';
      const tips = filterTipsForUser(u);
      let tipsN=0, wins=0, pts=0;
      tips.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const isFav = fav && (s(m.homeTeam||m.home||'')===fav || s(m.awayTeam||m.away||'')===fav);
        if (!isFav) return;
        const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome; const mult=tipDouble(t)?2:1;
        tipsN++; if (ok) wins++; if (ok&&o) pts += o*mult;
      });
      let rows=[['—','—','—','—']];
      if (fav){
        const hit = tipsN? wins/tipsN*100:0;
        const avg = tipsN? pts/tipsN:0;
        rows=[[fav, tipsN, fmt(hit)+'%', fmt(avg)]];
      }
      fillRows("tableFavBias", rows);
    })();

    // --- Odds-range teljesítmény ---
    (function(){
      const u = $("selOddsRangeUser").value || masterVal;
      const a = computeUserAgg(u);
      const orows = Object.values(a.rangeAgg).map(b=>{
        const hit = b.tips ? b.wins/b.tips*100 : 0;
        const avg = b.tips ? b.ptsS/b.tips : 0;
        const roi = b.stake ? (b.ret - b.stake)/b.stake : 0;
        return [b.name, b.tips, fmt(hit)+'%', fmt(avg), fmt(roi)];
      });
      fillRows("tableOddsRange", orows);
    })();

    // --- Sportfogadás-mutató ---
    (function(){
      const u = $("selBetSimUser").value || masterVal;
      const tips = filterTipsForUser(u);
      const totalTips = tips.length;
      let flatStake=0, flatReturn=0, correct=0, mixStake=0, mixReturn=0;
      tips.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome; const mult=tipDouble(t)?2:1;
        flatStake += 1; mixStake += mult;
        if (ok){ correct++; flatReturn += o; mixReturn += o*mult; }
      });
      const flatProfit = flatReturn-flatStake, mixProfit=mixReturn-mixStake;
      const flatRoi = flatStake? flatProfit/flatStake:0, mixRoi = mixStake? mixProfit/mixStake:0;
      const hitPct  = totalTips? correct/totalTips*100:0;
      fillRows("tableBetSim", [
        ['Flat 1 egység/tipp',     fmt(hitPct)+'%', fmt(flatStake), fmt(flatReturn), fmt(flatProfit), fmt(flatRoi)],
        ['Flat + duplák 2 egység', fmt(hitPct)+'%', fmt(mixStake),  fmt(mixReturn),  fmt(mixProfit),  fmt(mixRoi)]
      ]);
    })();

    // --- Bankroll userlista (ligaszintű tips-ból) ---
    (function(){
      const tipsL = filterTipsForLeague();
      const bankSel = $("bankUserSel");
      const prevVal = bankSel.value;
      bankSel.innerHTML = "";
      const uniqUsers = [...new Set(tipsL.map(t=> s(t.user)))];
      uniqUsers
        .map(email => ({ email, nick: state.users[email]?.nick || email }))
        .sort((a,b)=> a.nick.localeCompare(b.nick, 'hu', {sensitivity:'base'}))
        .forEach(({email,nick})=>{ const o=document.createElement('option'); o.value=email; o.textContent=nick; bankSel.appendChild(o); });
      // default: viewer if benne van, különben első / maradék
      if (uniqUsers.length){
        if (uniqUsers.includes(prevVal)) bankSel.value = prevVal;
        else if (state.viewer && uniqUsers.includes(state.viewer)) bankSel.value = state.viewer;
        else bankSel.selectedIndex = 0;
      }
      bankSel.onchange = recomputeBankroll;
      recomputeBankroll();
    })();

    // ======= LIGA BLOKK (változatlan logika) =======
    const tipsL   = filterTipsForLeague();
    const byUserL = groupBy(tipsL, t=> s(t.user));
    const byMatchL= groupBy(tipsL, t=> s(t.matchId));

    // Tippeloszlás
    let c1=0,cX=0,c2=0; const perRoundPick={};
    for (const t of tipsL){
      const m=state.matches[s(t.matchId)]; if(!m) continue; const r=matchRound(m);
      const p=tipChoice(t); if(!p) continue;
      if (p==='1') c1++; else if (p==='X') cX++; else if (p==='2') c2++;
      (perRoundPick[r] ||= {'1':0,'X':0,'2':0})[p]++;
    }
    const sum=c1+cX+c2 || 1;
    const pdRows=[[`Összesen`, fmt(c1/sum*100)+'%', fmt(cX/sum*100)+'%', fmt(c2/sum*100)+'%']];
    selectedRounds().forEach(r=>{ const o=perRoundPick[r]||{'1':0,'X':0,'2':0}; const ssum=o['1']+o['X']+o['2']||1; pdRows.push([`F${r}`, fmt(o['1']/ssum*100)+'%', fmt(o['X']/ssum*100)+'%', fmt(o['2']/ssum*100)+'%']); });
    fillRows("tablePickDist", pdRows, true);

    // Legnagyobb meglepetések (Top 5)
    const surprisesUseDouble = !!($("chkSurpriseDouble")?.checked);
    const topSurprises=[];
    tipsL.forEach(t=>{
      const m=state.matches[s(t.matchId)]; if(!m || !m.outcome) return;
      const p=tipChoice(t); const d=tipDouble(t); const o=getOdds(m,p)||0;
      if (p===m.outcome && o){
        const mult = (surprisesUseDouble && d) ? 2 : 1;
        const pts = o*mult;
        const label = `${s(m.homeTeam||m.home||'?')} – ${s(m.awayTeam||m.away||'?')}`;
        topSurprises.push({u:s(t.user), label, p, pts});
      }
    });
    topSurprises.sort((a,b)=> b.pts - a.pts);
    fillRows("tableTopSurprises", topSurprises.slice(0,5).map(x=>[
      state.users[x.u]?.nick||x.u, x.label, x.p, fmt(x.pts)
    ]));

    // Kimaradt ziccerek
    const missMap = new Map();
    for (const [mid, list] of Object.entries(byMatchL)){
      const m = state.matches[mid]; if (!m || !m.outcome) continue;
      for (const t of list){
        const pick = tipChoice(t); if (!pick) continue;
        if (pick === m.outcome) continue;
        const o = getOdds(m, pick) || 0; if (!o) continue;
        const key = `${mid}|${pick}|${o.toFixed(3)}`;
        const rec = missMap.get(key) || { mid, pick, o, users: new Set() };
        rec.users.add(s(t.user));
        missMap.set(key, rec);
      }
    }
    const missed = [...missMap.values()].sort((a,b)=> a.o - b.o).slice(0,5);
    const missRows = missed.map(x=>{
      const m = state.matches[x.mid];
      const label = `${s(m?.homeTeam||m?.home||'?')} – ${s(m?.awayTeam||m?.away||'?')}`;
      const nicks = [...x.users].map(u=> s(state.users[u]?.nick || u));
      const cell = `<details><summary>${nicks.length}</summary>${nicks.map(n=>`<span class="pill">${n}</span>`).join('')}</details>`;
      return [label, x.pick, fmt(x.o), cell];
    });
    fillRows("tableMissedSitters", missRows);

    // Forduló-győzelmek
    const perRoundPtsL  = {};
    const perRoundPtsLD = {};
    for (const [u, list] of Object.entries(byUserL)){
      list.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome; const d=tipDouble(t);
        const ptsS = (ok&&o)? o:0;
        const ptsD = (ok&&o)? (d?2:1)*o:0;
        const r=matchRound(m);
        (perRoundPtsL[u]  ||= {}); perRoundPtsL[u][r]  = (perRoundPtsL[u][r]  ||0)+ptsS;
        (perRoundPtsLD[u] ||= {}); perRoundPtsLD[u][r] = (perRoundPtsLD[u][r] ||0)+ptsD;
      });
    }
    const useRWDouble = !!($("chkRoundWinsDouble")?.checked);
    const roundWins = {};
    const rounds = selectedRounds();
    rounds.forEach(r=>{
      let max = -1; const winners=[];
      for (const u of Object.keys(byUserL)){
        const v = (useRWDouble ? perRoundPtsLD[u]?.[r] : perRoundPtsL[u]?.[r]) || 0;
        if (v>max){ max=v; winners.length=0; winners.push(u); }
        else if (v===max){ winners.push(u); }
      }
      if (max>0){
        winners.forEach(u=>{ roundWins[u]=(roundWins[u]||0)+1; });
      }
    });
    const roundWinRows = Object.entries(roundWins).map(([u,c])=>({nick:state.users[u]?.nick||u, c}))
      .sort((a,b)=> b.c - a.c).slice(0,10);
    fillRows("tableRoundWins", roundWinRows.length ? roundWinRows.map(x=>[x.nick, x.c]) : [['—','—']]);

    // Upset hunter (felhasználók)
    const upsetByUser = {};
    tipsL.forEach(t=>{
      const m=state.matches[s(t.matchId)]; if(!m || !m.outcome) return;
      const p=tipChoice(t); if(!p) return;
      const o=getOdds(m,p)||0; if(!o) return;
      const maxO = Math.max(getOdds(m,'1')||0, getOdds(m,'X')||0, getOdds(m,'2')||0);
      if (Math.abs(o-maxO) < 1e-9){
        const u=s(t.user);
        const ok = (p===m.outcome);
        const ptsS = ok? o:0;
        (upsetByUser[u] ||= {tips:0,hits:0,ptsS:0});
        upsetByUser[u].tips += 1;
        if (ok){ upsetByUser[u].hits += 1; upsetByUser[u].ptsS += ptsS; }
      }
    });
    const upsetRowsUsers = Object.entries(upsetByUser).map(([u,st])=>{
      const pct = st.tips? st.hits/st.tips*100:0;
      const avg = st.tips? st.ptsS/st.tips:0;
      return {nick:state.users[u]?.nick||u, tips:st.tips, hits:st.hits, pct, avg};
    }).sort((a,b)=> b.pct - a.pct || b.hits - a.hits || b.avg - a.avg);
    fillRows("tableUpsetUsers", upsetRowsUsers.length ? upsetRowsUsers.map(r=>[
      r.nick, r.tips, r.hits, fmt(r.pct)+'%', fmt(r.avg)
    ]) : [['—','—','—','—','—']]);

    // Sáv-nyerő (ROI)
    const lRange={low:{name:'≤1.80',stake:0,ret:0},mid1:{name:'1.81–2.50',stake:0,ret:0},mid2:{name:'2.51–3.50',stake:0,ret:0},high:{name:'≥3.51',stake:0,ret:0}};
    tipsL.forEach(t=>{
      const m=state.matches[s(t.matchId)]; if(!m) return;
      const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome;
      if (!o) return;
      const b=(o<=1.8?'low':(o<=2.5?'mid1':(o<=3.5?'mid2':'high'))); lRange[b].stake += 1; if (ok) lRange[b].ret += o;
    });
    const rArr = Object.values(lRange).map(b=>({name:b.name, roi: b.stake? (b.ret-b.stake)/b.stake:0}));
    rArr.sort((a,b)=> b.roi - a.roi);
    $("rangeWinnerVal").textContent = rArr.length? `${rArr[0].name} • ROI ${fmt(rArr[0].roi)}` : '—';

    // A hét meccse
    let mowLabel='—', mowAvg=null;
    for (const [mid, list] of Object.entries(byMatchL)){
      const m=state.matches[mid]; if(!m) continue;
      let tot=0;
      list.forEach(t=>{
        const p=tipChoice(t); const d=tipDouble(t); const o=getOdds(m,p)||0;
        const pts = (m.outcome && p===m.outcome && o)? o*(d?2:1):0;
        tot+=pts;
      });
      const avg = list.length? tot/list.length:0;
      if (mowAvg==null || avg>mowAvg){
        mowAvg = avg;
        mowLabel = `${s(m.homeTeam||m.home||'?')} – ${s(m.awayTeam||m.away||'?')}`;
      }
    }
    $("matchOfWeekText").textContent = mowLabel;
    $("matchOfWeekAvg").textContent = mowAvg!=null? fmt(mowAvg) : '—';

    // Early vs Late
    let earlyTips=0, earlyHits=0, lateTips=0, lateHits=0, usable=0;
    for (const t of tipsL){
      const m = state.matches[s(t.matchId)]; if (!m) continue;
      const start = getMatchStartMs(m);
      if (!start) continue;
      const tms = getTipTimeMs(t);
      const isEarly = tms <= (start - 6*60*60*1000);
      const ok = (m.outcome && tipChoice(t)===m.outcome);
      if (isEarly){ earlyTips++; if (ok) earlyHits++; }
      else { lateTips++; if (ok) lateHits++; }
      usable++;
    }
    const elRows = usable
      ? [['Korai (≤ -6h)', earlyTips, earlyTips? fmt(earlyHits/earlyTips*100)+'%':'—'],
         ['Késői (> -6h)',  lateTips,  lateTips?  fmt(lateHits/lateTips*100)+'%':'—']]
      : [['—','—','—'],['—','—','—']];
    fillRows("tableEarlyLate", elRows);

    // ROI toplista
    const roiArr = Object.entries(byUserL).map(([u,list])=>{
      let stake=0, ret=0, hit=0;
      list.forEach(t=>{
        const m=state.matches[s(t.matchId)]; if(!m) return;
        const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome;
        if (!o) return;
        stake += 1; if (ok){ hit++; ret += o; }
      });
      const profit = ret - stake;
      const roi = stake? profit/stake:0;
      const hitPct = stake? hit/stake*100:0;
      return { u, nick: state.users[u]?.nick || u, stake, hitPct, profit, roi };
    }).filter(x=> x.stake>0)
      .sort((a,b)=> b.roi - a.roi || b.profit - a.profit);
    const roiRows = roiArr.map((r,i)=>[(i+1)+'.', r.nick, r.stake, fmt(r.hitPct)+'%', fmt(r.profit), fmt(r.roi)]);
    fillRows("tableRoiTop", roiRows.length? roiRows : [['—','—','—','—','—','—']]);

    // Tippmódosítások
    const rset = new Set(selectedRounds());
    const groups = new Map(); // key: user|match -> array of tips (ALL versions)
    for (const t of state.tips){
      const mid = s(t.matchId); const m = state.matches[mid];
      if (!m) continue;
      if (!rset.has(matchRound(m))) continue;
      const k = `${s(t.user)}|${mid}`;
      (groups.get(k) || groups.set(k, []).get(k)).push(t);
    }
    let modsTotal=0, modsCorrect=0;
    const perMatchMods = new Map(); // mid -> {count, users: Map<email,count>}
    for (const [k, arr] of groups.entries()){
      const [email, mid] = k.split('|');
      arr.sort((a,b)=> getTipTimeMs(a) - getTipTimeMs(b));
      if (arr.length<=1) continue;
      modsTotal++;
      const final = arr[arr.length-1];
      const m = state.matches[mid];
      const ok = (m?.outcome && tipChoice(final)===m.outcome);
      if (ok) modsCorrect++;
      const rec = perMatchMods.get(mid) || { count:0, users:new Map() };
      rec.count += 1;
      rec.users.set(email, (rec.users.get(email)||0)+1);
      perMatchMods.set(mid, rec);
    }
    $("modHitRate").textContent = modsTotal? `${fmt(modsCorrect/modsTotal*100)}% (${modsCorrect}/${modsTotal})` : '—';
    const topMod = [...perMatchMods.entries()]
      .map(([mid,rec])=>{
        const m = state.matches[mid];
        const label = `${s(m?.homeTeam||m?.home||'?')} – ${s(m?.awayTeam||m?.away||'?')}`;
        const users = [...rec.users.entries()].map(([u,c])=>({nick: state.users[u]?.nick||u, c}));
        users.sort((a,b)=> b.c - a.c || a.nick.localeCompare(b.nick,'hu',{sensitivity:'base'}));
        return {label, count:rec.count, users};
      })
      .sort((a,b)=> b.count - a.count)
      .slice(0,5);
    const modRows = topMod.length? topMod.map(r=>{
      const pills = `<details><summary>${r.users.length}</summary>${r.users.map(u=>`<span class="pill">${u.nick}${u.c>1?` ×${u.c}`:''}</span>`).join('')}</details>`;
      return [r.label, r.count, pills];
    }) : [['—','—','—']];
    fillRows("tableMostModified", modRows);
  }

  function recomputeBankroll(){
    const tipsL = filterTipsForLeague();
    const bankUser = $("bankUserSel").value;
    const X = Math.max(1, Number($("bankStake").value)||0);
    const list = tipsL.filter(t=> s(t.user)===bankUser);
    let tipsN=0, stake=0, ret=0, wins=0;
    list.forEach(t=>{
      const m = state.matches[s(t.matchId)]; if(!m) return;
      const p=tipChoice(t); const o=getOdds(m,p)||0; const ok=m.outcome && p===m.outcome;
      tipsN += 1; stake += X; if (ok){ wins++; ret += o*X; }
    });
    const profit = ret - stake;
    const roi = stake? profit/stake:0;

    $("bankOutTips").textContent = tipsN;
    $("bankOutStake").textContent = Math.round(stake);
    $("bankOutReturn").textContent = Math.round(ret);
    $("bankOutProfit").textContent = Math.round(profit);
    $("bankOutRoi").textContent = fmt(roi);

    const el = $("bankSummary");
    if (profit >= 0){
      el.className = "bank-summary result-good";
      el.textContent = `Ha minden tippedre ${X} Ft-ot tettél volna, összesen ${Math.round(profit)} Ft nyereséged lett volna, gratuláció!`;
    } else {
      el.className = "bank-summary result-bad";
      el.textContent = `Ha minden tippedre ${X} Ft-ot tettél volna, összesen ${Math.abs(Math.round(profit))} Ft veszteséged lett volna.`;
    }
  }

  // ===== helpers =====
  function groupBy(arr, fn){ const m={}; for(const x of arr){ const k=fn(x); (m[k] ||= []).push(x); } return m; }
  function mergeSeries(series){ if (!series.length) return []; const n=Math.max(...series.map(s=>s.length)); const out=[]; for(let i=0;i<n;i++){ let s=0,c=0; series.forEach(a=>{ if (i<a.length){ s+=a[i]; c++; } }); out.push(c? s/c:0); } return out; }
  function drawSpark(el, arr){
    if (!arr.length){ el.innerHTML=''; return; }
    const w=120,h=32, min=Math.min(...arr), max=Math.max(...arr);
    const sx=i=> (i/(Math.max(1,arr.length-1)))*(w-2)+1;
    const sy=v=>{ if(max===min) return h/2; const t=(v-min)/(max-min); return h-2 - t*(h-4); };
    let d=''; arr.forEach((v,i)=> d+=(i?' L':'M')+sx(i)+' '+sy(v));
    el.innerHTML=`<svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><path d="${d}" fill="none" stroke="var(--accent)" stroke-width="2"/></svg>`;
  }
  function fillRows(tbodyId, rows, highlightFirst=false){
    const tb=$(tbodyId); if (!tb) return;
    tb.innerHTML='';
    rows.forEach((r,i)=>{ const tr=document.createElement('tr'); if(highlightFirst && i===0) tr.className='hl'; tr.innerHTML=r.map(c=>`<td>${c}</td>`).join(''); tb.appendChild(tr); });
  }
  function fillBiasTable(b){
    const tb=$("tableBias"); tb.innerHTML='';
    [['1','Hazai'],['X','Döntetlen'],['2','Vendég']].forEach(([k,lab])=>{
      const p=b[k].pick, h=b[k].hit, sr=p? h/p*100:0;
      tb.appendChild(row([lab, p, fmt(sr)+'%']));
    });
    function row(cells){ const tr=document.createElement('tr'); tr.innerHTML=cells.map(c=>`<td>${c}</td>`).join(''); return tr; }
  }

  // ===== kattintható ? buborék =====
  function initHelpBubbles(){
    const helps = document.querySelectorAll('.qq');
    helps.forEach(el=>{
      const t = el.getAttribute('title');
      if (t){ el.dataset.help = t; el.removeAttribute('title'); }
      el.setAttribute('role','button');
      el.setAttribute('tabindex','0');
    });

    let openPop = null;

    function closePop(){ openPop?.remove(); openPop=null; }
    function openFor(el){
      closePop();
      const msg = el.dataset.help || '';
      if (!msg) return;
      const r = el.getBoundingClientRect();
      const pop = document.createElement('div');
      pop.className = 'help-pop';
      pop.innerHTML = `<button class="close" aria-label="Bezárás">✕</button><div style="padding-right:22px">${msg}</div>`;
      document.body.appendChild(pop);
      const vw = window.innerWidth, vh = window.innerHeight;
      let left = Math.min(vw - pop.offsetWidth - 8, Math.max(8, r.left));
      let top  = r.bottom + 8;
      if (top + pop.offsetHeight + 8 > vh){ top = Math.max(8, r.top - 8 - pop.offsetHeight); }
      pop.style.left = left + "px";
      pop.style.top  = top + "px";
      pop.querySelector('.close').addEventListener('click', closePop);
      openPop = pop;
    }

    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('.qq');
      if (btn){ e.preventDefault(); openFor(btn); return; }
      if (openPop && !e.target.closest('.help-pop')) closePop();
    });
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') closePop();
      if ((e.key==='Enter'||e.key===' ') && document.activeElement?.classList?.contains('qq')){
        e.preventDefault(); openFor(document.activeElement);
      }
    });
    window.addEventListener('scroll', ()=>{ openPop?.remove(); openPop=null; }, true);
    window.addEventListener('resize', ()=>{ openPop?.remove(); openPop=null; });
  }
</script>
</body>
</html>
